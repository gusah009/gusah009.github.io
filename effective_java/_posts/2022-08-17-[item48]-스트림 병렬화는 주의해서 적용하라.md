---
title: "[item48] 스트림 병렬화는 주의해서 적용하라"
toc_label: "[item48]"
toc: false
toc_sticky: false
---

> **스트림 병렬화는 주의해서 적용하라**

자바는 스트림을 지원하면서 동시에 **병렬 연산이 가능한 스트림**인 `parallel stream`을 지원했습니다. 병렬 스트림 파이프라인은 충분히 직관적이고 쉬운 기술이지만 **자칫 잘못하면 최악의 결과**를 낳을 수 있습니다. 그 이유에 대해서 살펴보겠습니다.

## parallel과 limit
책에서 메르센 소수를 구하는 방법으로 `parallel stream`과  `limit`를 사용했을 때 더 느려지는 것을 보여주고 있습니다. 그 이유는 바로 `limit`에 있는데, 옮긴이가 아주 잘 설명해주고 있습니다.

옮긴이의 말을 빌리자면, `limit`를 다룰 때 CPU 코어가 남으면 해당 코어를 모두 사용해 버립니다. 

```java
public static void main(String[] args) {
  primes().map(p -> TWO.pow(p.intValueExact()).subtract(ONE))
      .filter(mersenne -> mersenne.isProbablePrime(50))
      .limit(20)
      .forEach(System.out::println);
}

static Stream<BigInteger> primes() {
  return Stream.iterate(TWO, BigInteger::nextProbablePrime);
}
```

단적인 예로 코어가 4개인 CPU에서 `limit(20)`으로 20번째 메르센 소수를 찾도록 했다고 가정해보겠습니다. 만약 20번째 메르센 소수를 찾는데 코어가 4개가 남아있다면, 20번째, 21번째, 22번째, 23번째 총 4개의 메르센 소수를 추가로 찾도록 CPU에게 명령을 내려버립니다. (찾아졌을 때 21, 22, 23번째 소수는 버리면 되기 때문) 

그래서 **단순히 20번째 메르센 소수를 찾고 끝날 일**이 최악의 경우에 이토록 오래 걸리게 되는 것입니다.

이처럼 자동 병렬화 파이프라인이 최적화시킬 방법을 못찾는 경우 오히려 더 느려진다는 것을 알 수 있습니다.

## 병렬처리에 좋은 스트림 소스
병렬처리에 좋은 스트림 소스론 대체로 `ArrayList`, `HashSet`, `ConcurrentHashMap`, 배열, int 범위, long 범위가 있습니다. 그 이유는 바로 데이터를 원하는 크기로 정확하게 나누고 분배할 수 있어서 다수의 스레드에 분배하기 좋기 때문입니다.

또 위 자료구조들의 공통점은 원소들을 순차적으로 실행할 때의 **참조 지역성**이 뛰어나다는 것입니다. 이웃한 원소의 참조들이 메모리에 연속해서 저장되어 있기 때문에 메모리로부터 캐시로 원소들을 가져올 때 빠르다는 장점이 있습니다.

> 물론 참조들이 가리키는 실제 객체가 **메모리에서 서로 떨어져 있을 수** 있는데, 그러면 **참조 지역성이 나빠져** 성능이 나빠집니다. **기본 타입 배열**은 항상 메모리에 연속해서 저장되기 때문에 참조 지역성이 가장 뛰어납니다.

## 병렬처리에 좋은 종단 연산
병렬처리에 좋은 종단 연산으론 `reduce`, `min`, `max`, `count`, `sum`, `anyMatch`, `allMatch`, `noneMatch`가 있습니다.

## 스트림 병렬화는 주의해서 적용하라
스트림 병렬화가 주는 장점이 많음에도 불구하고 이 장의 제목처럼 **스트림 병렬화는 주의해서 사용해야 합니다.** 스트림을 잘못 병렬화하면 처음 예시처럼 성능이 나빠질 수도 있고, 더 나아가서 결과 자체가 잘못되거나 예상치 못한 동작이 발생할 수 있습니다.

실제 위의 메르센 소수를 병렬 스트림으로 구하는 예시에서 완료되더라도 소수를 발견한 순서대로 출력되지 않을 수 있습니다.

심지어 데이터 소스 스트림이 효율적으로 나뉘어지고, 병렬화하거나 빨리 끝나는 종단 연산을 사용하고, 함수 객체들도 간섭하지 않더라도 **병렬화 자체에 드는 비용을 상쇄시키지 못하면** 성능 향상은 미미할 수 있습니다. 

## 결론
그러므로 계산도 올바로 수행하고 성능도 빨라질 거라는 **확신 없이는 병렬 스트림은 시도조차 하지 말도록** 합시다. 병렬화하는 편이 낫다고 믿더라도, 테스트를 꾸준히 해보고 성능 지표를 유심하게 살펴봐야 합니다. 계산도 정확하고 성능이 좋아졌음이 확실해졌을 때에만 병렬화 버전 코드를 운영 코드에 반영합시다.