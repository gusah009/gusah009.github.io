---
title: "[item39] 명명 패턴보다 Annotation을 사용하라"
toc_label: "[item39]"
toc: false
toc_sticky: false
---

> **명명 패턴보다 Annotation을 사용하라**

`Annotation`이 나오기 전 `Java`에서는 어떤 도구나 프레임워크가 해당 코드를 다룰 수 있게 명명 패턴을 적용해 왔습니다. 명명 패턴은 간단히 말해 이름을 *test* 로 시작하게 하는 것 처럼 이름으로 그 역할을 구분하는 것입니다. 그럼 `Annotation`이 나오면서 왜 명명 패턴이 사라지게 됐는 지, `Annotation`의 장점은 무엇인지 한 번 알아보겠습니다.

## 명명 패턴의 단점
### 1. 오타에 민감하다.
`testMethod()` 로 작성해야 할 코드를 `tsetMethod()`로 작성하게 되면 명명 패턴에서는 해당 테스트를 놓치게 됩니다.

### 2. 사용 범위를 알 수 없다.
사용자가 프레임워크의 동작 방식을 제대로 이해하지 못하고, 메서드에 붙여야 할 prefix를 클래스에 붙일 수도 있습니다. 하지만 어떤 에러나 경고 메시지도 띄워주지 않습니다.

### 3. 프로그램 요소를 매개변수로 전달할 좋은 방법이 없다.
해당 프레임워크에 어떤 인자를 전달하고 싶어도, 마땅한 방법이 없습니다. 예를 들어 `RuntimeException` 예외를 던져야만 성공한다고 테스트 프레임워크에 알려주고 싶을 때 명명 패턴은 `testMethodExpectRuntimeException()`과 같은 방식으로 할 수 밖에 없습니다. 여기서도 위의 **1. 오타에 민감하다.** 문제점이 똑같이 드러납니다.

## Annotation의 등장
`Annotation`이 등장하면서 위 문제들을 깔끔하게 해결할 수 있게 되었습니다.

### JUnit4의 `@Test`
```java
@Target({ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface Test {
  Class<? extends Throwable> expected() default Test.None.class;
  // ...
}
```
위 코드는 `JUnit4`의 `@Test` 어노테이션입니다. 위 코드에서 `@Target`과 `@Retention`을 살펴보겠습니다.

먼저 `@Target` 어노테이션은 해당 어노테이션이 선언될 수 있는 위치를 의미합니다. `@Test`는 메서드에 붙일 수 있음을 알 수 있습니다.
다음으로 `@Retention` 어노테이션은 해당 에너테이션의 생명 주기를 의미합니다. `@Retention` 어노테이션은 런타임 시 까지 유효하다는 것을 알 수 있습니다.
또한, 어노테이션은 받을 속성을 설정할 수 있습니다. 위의 `expected()` 속성은 `Throwable`의 하위 타입의 클래스 즉, 예외클래스를 인자로 받겠다는 뜻입니다.

이제 어노테이션에 대해 알았으니, 어노테이션이 명명패턴의 단점을 어떻게 극복했는 지 알아보겠습니다.

## Annotation으로 명명 패턴의 단점 극복하기
### 1. 오타에 민감하다.
어노테이션의 잘못된 이름은 컴파일타임에 잡아줍니다. `@Test`를 `@Tset`으로 쳤다면 컴파일 에러를 얻을 수 있습니다.

### 2. 사용 범위를 알 수 없다.
앞서 본 `@Target` 메타 어노테이션이 선언될 수 있는 위치를 지정해줍니다. `@Test`를 클래스에 달면 컴파일에러를 얻을 수 있습니다.

### 3. 프로그램 요소를 매개변수로 전달할 좋은 방법이 없다.
어노테이션의 속성을 이용해 매개변수를 받을 수 있습니다. `@Test`의 `expected()`속성을 통해 테스트에서 기대되는 예외 값을 받을 수 있습니다.

## 결론
이번 장을 통해 애너테이션이 명명 패턴보다 낫다는 것을 알 수 있었습니다. 애너테이션으로 할 수 있는 일을 굳이 명명 패턴으로 처리할 필요는 없습니다.