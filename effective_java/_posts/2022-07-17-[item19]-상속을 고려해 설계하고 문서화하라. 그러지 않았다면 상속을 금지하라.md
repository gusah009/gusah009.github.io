---
title: "[item19] 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라"
toc_label: "[item19]"
toc: false
toc_sticky: false
---

> **상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라**

## 상속용 클래스의 문서화
앞 장에서 보았듯이 상속은 여러 부분에서 주의할 사항이 생깁니다. **따라서 상속용 클래스는 재정의 할 수 있는 메서드들을 내부적으로 어떻게 이용하는 지 문서로 남겨야 합니다.** 책에서 볼 수 있는 대로 `@implSpec`을 통해 해당 메서드를 재정의 했을 때 다른 메서드들에 어떤 영향을 끼칠 지 명시해야 합니다. 하지만 결국 이런 방식도 상속이 캡슐화를 깨버리는 상황에서 나오는 문제라고 볼 수 있습니다.

## 상속용 클래스 설계엔 마법을 부릴 수 없다.
책의 저자는 계속해서 상속용 클래스의 위험성에 대해 언급하고 있습니다. 상속용 클래스의 설계에는 뚜렷한 가이드라인이 없으며 **직접 하위 클래스를 만들어보는 것이 유일한 테스트 방법이라고 하고 있습니다.** 따라서 상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스를 만들어 검증해봐야 합니다.

## 상속용 클래스의 생성자는 재정의 메서드를 호출해선 안된다.
이 뿐만이 아니라, **상속용 클래스의 생성자는 재정의 메서드를 호출해선 안됩니다.** 상위 클래스의 생성자가 재정의 메서드를 호출한다면 상위 클래스의 재정의되기 전의 메서드가 호출되는 것이 아니라, 하위 클래스의 재정의 된 메서드가 호출되어 의도와 다르게 동작할 수 있기 때문입니다.

## `Cloneable`과 `Serializable`
`Cloneable`과 `Serializable` 인터페이스도 문제에 한 몫을 더합니다. 위의 생성자 문제와 비슷하게 상속용 클래스의 **`clone`과 `readObject`에선 모두 직접적이든 간접적이든 재정의 가능 메서드를 호출해서는 안됩니다.** 만약 `clone`에서 재정의 가능 메서드를 호출했다면 복제가 되기 전에 오작동이 일어날 수 있습니다. 이는 복제분 뿐만 아니라 원본 객체에도 피해를 줄 수 있기 때문에 매우 위험합니다.

## 굳이 클래스를 상속용으로 설계해야 하는가
지금까지 클래스를 상속용으로 설계하려면 큰 노력과 위험부담이 따른다는 것을 보았습니다. 따라서 추상 클래스나 인터페이스를 제외하곤 상속을 애초에 금지하는 것이 좋습니다.

> 왜 추상클래스와 인터페이스는 상속의 제약에서 제외되는 지 다음 장 **[item20]**에서 보겠습니다.

## 요약
상속용 클래스를 설계하기란 만만치 않습니다. 클래스 내부에서 스스로를 어떻게 사용하는지(자기사용 패턴) 모두 문서로 남겨야 하며, 일단 문서화한 것은 그 클래스가 쓰이는 한 반드시 지켜야 합니다. 다른 프로그래머가 고효율의 하위 클래스를 만들 수 있도록 일부 메서드를 `protected`로 제공해야 할 수 있습니다. 하지만 그 외에 클래스를 확장해야 할 명확한 이유가 없다면 상속을 금지하는 편이 나을 수 있습니다.