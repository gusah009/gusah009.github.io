---
date: '2022-08-11'
title: '[item45] 스트림은 주의해서 사용하라'
categories: ['effective_java']
summary: '`Java8`부터 스트림 API가 추가되었습니다. 이는 함수형 패러다임을 기본적으로 탑재하고, 다량의 데이터 처리 작업을 도와주는 역할로서 나왔습니다. 이번 장에서는 스트림이 무엇인지, 그리고 스트림을 언제 어떻게 써야 하는 지에 대해 알아보겠습니다.'
thumbnail: './effective_java_thumb.png'
---

> **스트림은 주의해서 사용하라**

`Java8`부터 스트림 API가 추가되었습니다. 이는 함수형 패러다임을 기본적으로 탑재하고, 다량의 데이터 처리 작업을 도와주는 역할로서 나왔습니다. 이번 장에서는 스트림이 무엇인지, 그리고 스트림을 언제 어떻게 써야 하는 지에 대해 알아보겠습니다.

## 스트림 API
스트림 API는 크게 세 파트로 나뉩니다. **소스 스트림(시작), 중간 연산, 종단 연산**입니다.
### 1. 소스 스트림(시작)
일단 스트림 API를 사용하려면 데이터를 담은 스트림을 생성해야 합니다. 대표적으로 `Arrays.stream()`나 `IntStream.range(exp1, exp2)`가 있습니다.

### 2. 중간 연산
스트림은 중간 연산을 **하나 이상** 가질 수 있는데, 각 중간 연산은 스트림을 어떠한 방식으로 변환합니다. `filter`의 경우 특정 조건을 만족하는 원소만 거를 수 있고, `map`의 경우 원소들에 모두 어떤 변화를 가해서 새로운 스트림을 반환합니다. 이 때문에 변환 전 스트림의 원소 타입과 변환 후 스트림의 원소 타입이 다를 수 있습니다.

### 3. 종단 연산
종단 연산은 중간 연산이 내놓은 스트림에 최종 연산을 가합니다. `toList()`와 같이 컬렉션에 담을 수도 있고, `findFirst()` 처럼 특정 원소를 선택할 수도 있습니다.

## 지연 평가 (Lazy Evaluation)
스트림은 종단 연산이 호출될 때 이뤄지며 종단 연산에 쓰이지 않는 데이터 원소는 계산에 쓰이지 않습니다. 아래 코드는 종단연산이 없는 스트림 연산입니다. 1, 2, 3 원소들이 출력될 것 같지만 아무것도 출력되지 않습니다. 이렇듯 종단 연산을 기준으로 연산이 진행되는 것을 지연 평가라고 합니다.
```java
IntStream.of(1, 2, 3)
    .map(i -> {
      System.out.println(i + " 호출!");
      return i + 1;
    });
// 아무것도 출력되지 않음.
```
지연 평가의 예시를 하나 더 보겠습니다. 아래와 같이 종단 연산이 `findFirst()`로 구성된 스트림입니다. 이번엔 종단 연산이 있기 때문에 1, 2, 3을 호출할 것 같지만 사실 1만 호출됩니다. `findFirst()`가 종단 연산이면, 사실 첫 번째 원소를 제외하고 이후의 데이터들은 더 이상 연산하는 것이 무의미합니다. 이를 스트림은 지연 평가를 통해 애초에 종단 연산에 쓰이지 않을 데이터 원소는 계산에 쓰이지 않습니다.
```java
IntStream.of(1, 2, 3)
    .map(i -> {
      System.out.println(i + " 호출!");
      return i + 1;
    })
    .findFirst();
// 1 호출!
```

## 스트림이 필요한 경우
스트림은 데이터 처리 작업에 있어서 코드를 훨씬 간결하게 해줍니다. 하지만 책에 나온 예시처럼 잘못 사용하면 유지보수를 어렵게 만드는 주범이 됩니다. 스트림을 사용한다면 대개 람다식이 내부적으로 들어가는데, 람다식은 이름이 없으므로 람다식에 쓰이는 매개변수는 반드시 이름을 잘 지어야 가독성을 높일 수 있습니다.

> char 값을 처리할 땐 스트림을 삼가는 게 좋습니다. `CharStream`이 따로 존재하지 않기 때문에, 책에 나온 바와 같이 `IntStream`을 반환합니다. 충분히 헷갈릴 수 있으므로 왠만하면 char 값들을 처리할 때는 스트림을 삼가는 편이 낫습니다.

스트림을 처음 사용하면 모든 반복문을 스트림으로 바꾸고 싶은 유혹에 빠집니다. 하지만 스트림을 너무 장황하게 사용하면 유지보수가 힘들어지고, 가독성이 떨어집니다. 저자는 스트림과 반복문을 적절하게 조합하는 게 최선이라고 말하고 있습니다.

아래와 같은 경우엔 스트림이 안성맞춤입니다.
1. 원소들의 시퀀스를 일관되게 변환한다. `map()`
2. 원소들의 시퀀스를 필터링한다. `filter()`
3. 원소들의 시퀀스를 하나의 연산을 사용해 결합한다. `sum()`, `max()`, `min()`
4. 원소들의 시퀀스를 컬렉션에 모은다. `groupby()`, `collect()`
5. 원소들의 시퀀스에서 특정 조건을 만족하는 원소를 찾는다. `findFirst()`, `findAny()`

## 스트림을 사용할 수 없는 경우
스트림을 아예 사용조차 할 수 없는 경우들이 있습니다.
1. 스트림에서는 지역 변수가 `final`인 변수만 읽을 수 있고, 지역 변수를 수정하는 건 불가능합니다.
2. 반복문에선 `return`으로 메서드에서 빠져나가거나 `break`, `continue`같이 종료하거나 건너뛸 수 있습니다. 또 검사 예외 같은 것을 던질 수 있지만 스트림에서는 불가능 합니다.

## 스트림을 사용하기 어려운 경우
스트림을 사용할 순 있지만 스트림을 사용하면 코드가 지저분해지는 경우가 있습니다. 스트림의 특징 중 하나는 데이터 파이프라인에서 그 단계가 끝나면 원래 값을 잃어버린다는 것입니다. 이런 특징 때문에 파이프라인 각 단계의 값을 참조해야 하는 경우엔 스트림보다 반복문이 더 가독성 높을 수 있습니다.

## 결론
스트림이 반복문보다 항상 더 나은 것은 아닙니다. 스트림이 더 나은 경우도 있고 반복문이 더 나은 경우도 있습니다. 그리고 수많은 작업이 이 둘을 조합했을 때 가장 멋지게 해결됩니다.

### Ref.
- [https://futurecreator.github.io/2018/08/26/java-8-streams/](https://futurecreator.github.io/2018/08/26/java-8-streams/)
- [https://futurecreator.github.io/2018/08/26/java-8-streams-advanced/](https://futurecreator.github.io/2018/08/26/java-8-streams-advanced/)