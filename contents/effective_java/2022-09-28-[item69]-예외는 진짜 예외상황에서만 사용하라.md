---
date: '2022-09-28'
title: '[item69] 예외는 진짜 예외상황에서만 사용하라'
categories: ['effective_java']
summary: '때때로 예외를 예외상황이 아닌, 특수한 목적으로 사용하려는 사람들이 있습니다. `effective java`에 나온 예시처럼 반복문의 종료 조건으로 예외를 이용하는 것을 볼 수 있습니다.'
thumbnail: './effective_java_thumb.png'
---

> **예외는 진짜 예외상황에서만 사용하라**

## 반복문 종료 조건으로 예외 상황 사용하기

때때로 예외를 예외상황이 아닌, 특수한 목적으로 사용하려는 사람들이 있습니다.

`effective java`에 나온 예시처럼 **반복문의 종료 조건으로 예외를 이용**하는 것을 볼 수 있습니다.

이런 시도를 한 이유는 JVM은 배열에 접근할 때마다 경계를 넘지 않는지 검사하는데, 반복문에도 이를 명시하면 **같은 일이 중복**되므로 하나를 생략한 것입니다.

하지만 이는 세 가지 측면에서 잘못된 추론입니다.
1. 예외는 예외 상황에 쓸 용도로 설계되었으므로 JVM 구현자 입장에서는 명확한 검사만큼 빠르게 만들어야 할 동기가 약합니다. 따라서 **최적화에 신경 쓰지 않았을 가능성이 높습니다.**
2. 코드를 `try-catch` 블록 안에 넣으면 **JVM이 적용할 수 있는 최적화가 제한됩니다.**
3. 배열을 순회하는 표준 관용구는 앞서 걱정한 **중복 검사를 수행하지 않습니다.** JVM이 알아서 최적화하여 없애줍니다.

실상은 **예외를 사용한 쪽이 표준 관용구보다 훨씬 느립니다.** 가독성도 잃고, 성능도 잃는 셈입니다.

예외를 사용한 반복문의 문제는 여기서 끝이 아닙니다. `try-catch`로 예외를 잡아버렸기 때문에, 실제 예외 상황에서 예외를 놓칠 수 있습니다.

## '상태 의존적' 메서드를 제공하는 클래스는 '상태 검사' 메서드도 함께 제공한다.
`iterator`의 `next()` 메서드는 반드시 다음 값이 있어야 다음 값을 반환합니다.

만약 마지막 원소인데 `next()`를 호출했다면 `NoSuchElementException`을 일으키게 됩니다.

현재 `iterator`의 **상태에 의존하는 `next()` 메서드는 대표적인 '상태 의존적' 메서드**라고 볼 수 있습니다.

이런 '상태 의존적' 메서드는 '상태 검사' 메서드도 함께 제공하여야 **클라이언트가 항상 예외로써 상태를 확인하는 불상사를 막을 수 있습니다.**

`next()`의 '상태 검사' 메서드는 `hasNext()`입니다. `hasNext()`를 통해 상태를 검사하고 `next()`를 수행할 것인지 아닌지 결정할 수 있습니다.

## 결론
결론은 간단합니다. 예외는 예외 상황에서 쓸 의도로 설계되었으니, 정상적인 제어 흐름에서 사용하지 않도록 합시다. 또한 API를 제공할 때 예외를 강요하게끔 설계해서도 안됩니다.