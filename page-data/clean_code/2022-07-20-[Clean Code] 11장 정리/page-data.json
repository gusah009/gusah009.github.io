{"componentChunkName":"component---src-templates-post-template-tsx","path":"/clean_code/2022-07-20-[Clean Code] 11장 정리/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<blockquote>\n<p>복잡성은 죽음이다. 개발자에게서 생기를 앗아가며, 제품을 계획하고 제작하고 테스트하기 어렵게 만든다.</p>\n<ul>\n<li>레이 오지(Microsoft CTO)</li>\n</ul>\n</blockquote>\n<h2>11장. 시스템</h2>\n<h3>시스템 제작과 시스템 사용을 분리하라</h3>\n<p>시스템의 제작과 시스템 사용을 분리하라는 말은, 소프트웨어 관점에서 살펴보면 어플리케이션 객체를 제작하고 의존성을 서로 ‘연결’하는 준비 과정과 런타임 로직을 분리하라는 말과 같습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token class-name\">Service</span> <span class=\"token function\">getService</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>service <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span>\n    service <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">MyServiceImpl</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> service<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위 코드는 항상 <code class=\"language-text\">service</code>가 <code class=\"language-text\">null</code>이 아님을 보장해줌과 동시에 <code class=\"language-text\">service</code>의 실제 구현체를 지연 로딩함으로써 불필요한 부하를 막을 수 있다는 장점을 가지고 있습니다. 하지만 <code class=\"language-text\">MyServiceImpl()</code>이라는 구현체에 의존하고 있으며, <strong>객체의 생성</strong>과 <strong>반환</strong>이라는 두 가지 작업을 하고 있기 때문에 SRP를 위반합니다.</p>\n<p>이 때 필요한 것이 바로 관심사의 분리입니다.</p>\n<h4>Main 분리</h4>\n<p><img src=\"https://user-images.githubusercontent.com/26597702/179993489-2e183b2d-b344-4dbd-8dc5-8fb7fbaf4c52.png\" alt=\"제목 없는 다이어그램 drawio\"></p>\n<p><code class=\"language-text\">main</code> 코드에서 생성과 관련된 모든 코드를 입력하고, 애플리케이션에서는 여기서 생성된 객체를 사용하는 방법을 말합니다. 애플리케이션 입장에서는 객체가 생성되는 과정을 전혀 모릅니다. 단지 모든 객체가 적절히 생성되었다고 가정하고 코드를 실행시킵니다.</p>\n<h4>팩토리</h4>\n<p><img src=\"https://user-images.githubusercontent.com/26597702/179995225-ab7000db-c085-4f3f-b570-f011237f0ccf.png\" alt=\"클린코드 factory drawio\"></p>\n<p><strong>ABSTRACT FACTORY 패턴</strong>을 활용하여 팩토리를 통해 객체를 생성하는 방법입니다. 어떤 객체가 나오는 지는 애플리케이션이 알 수 없고, 오로지 팩토리를 통해서만 실제 객체를 사용할 수 있습니다.</p>\n<h4>의존성 주입</h4>\n<p>사용과 제작을 분리하는 가장 강력한 메커니즘 중 하나는 <strong>의존성 주입</strong>입니다. 의존성 주입은 컨테이너를 활용해 런타임시에 객체를 넘겨줄 수 있습니다. 물론, 위에서 언급한 지연 로딩 역시 프록시를 생성하는 방법을 통해 사용할 수 있습니다.</p>\n<h3>자바 프록시</h3>\n<p>책에서는 자바 프록시를 활용하여 횡단 관심사를 분리하는 예시를 잘 보여주고 있습니다. 프록시로 감싼 객체에서 실제 <code class=\"language-text\">getAccounts()</code>와 <code class=\"language-text\">setAccounts()</code> 위아래로 원하는 추가 동작을 실행해 주고 있습니다.</p>\n<h3>순수 자바 AOP 프레임워크</h3>\n<p>대부분의 프록시 코드는 비슷해서 자동화가 가능했습니다. 따라서 <code class=\"language-text\">xml</code>파일과 같은 설정파일로 사용자가 모르게 프록시 객체를 생성할 수 있었습니다. 책에 나온 예시처럼 ‘러시아 인형’형식으로 프록시를 쌓고 또 쌓을 수 있었습니다.</p>\n<h3>테스트 주도 시스템 아키텍처 구축</h3>\n<p>위의 방법들을 이용하여 관심사를 분리하면, 우리가 사용할 객체는 비즈니스 로직만 남게 되고 진정한 <strong>테스트 주도 아키텍처 구축</strong>이 가능해집니다.</p>\n<h3>의사 결정을 최적화하라</h3>\n<p>모듈을 나누고 관심사를 분리하면 지엽적인 관리와 결정이 가능해짐을 보았습니다. 하지만 아주 큰 시스템에서는 한 사람이 모든 결정을 내리기 어렵습니다. 가능한 마지막 순간까지 결정을 미룸으로써 충분한 정보를 바탕으로 관심사를 충분히 분리한 뒤에 코드를 작성하는 것이 좋습니다.</p>\n<h3>결론</h3>\n<p>시스템이 얼마나 크던 시스템은 깨끗하고 단순해야 합니다. 구현 관심사를 최대한 분리하고 최적의 비스니스 로직을 작성하도록 합시다.</p>","frontmatter":{"title":"[Clean Code] 11장 정리","summary":"복잡성은 죽음이다. 개발자에게서 생기를 앗아가며, 제품을 계획하고 제작하고 테스트하기 어렵게 만든다.","date":"2022.07.20.","categories":["clean_code"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAA40lEQVQoz2NYfuUm2YiBepqv3lp57faKq7eWXbq+7PINNLQULIhL860lF6/OPnF28YWra28/WHPr/uqb90Dkjbsg8tb9tXcerr55H7vmpVduzt6x7+LVa0v3H2lYtqpx8YoJ23Z1b9gyeff+9tXrJ2zbVbdgce/m7dg1L7t6c+rmXYdOXpyzbV/ZjNnZHd05Xb1pTa1tq9ZVzpqX09WbVFuf3zdh2aXrK67eQte84uqtReevzDh6ZtH5Kyuu3oKoWHHt9qrrd5ZdBilYef0OXBuWAFtx9dYqDBXLr9ygQ1SRqBkA4gfGYXqbPI4AAAAASUVORK5CYII="},"images":{"fallback":{"src":"/static/524d5d37d834bb1b9ad60ee4176eb8a9/340cf/clean_code_thumb.jpg","srcSet":"/static/524d5d37d834bb1b9ad60ee4176eb8a9/c5762/clean_code_thumb.jpg 567w,\n/static/524d5d37d834bb1b9ad60ee4176eb8a9/c8d06/clean_code_thumb.jpg 1134w,\n/static/524d5d37d834bb1b9ad60ee4176eb8a9/340cf/clean_code_thumb.jpg 2268w","sizes":"(min-width: 2268px) 2268px, 100vw"},"sources":[{"srcSet":"/static/524d5d37d834bb1b9ad60ee4176eb8a9/2c04c/clean_code_thumb.webp 567w,\n/static/524d5d37d834bb1b9ad60ee4176eb8a9/f5de0/clean_code_thumb.webp 1134w,\n/static/524d5d37d834bb1b9ad60ee4176eb8a9/c0f58/clean_code_thumb.webp 2268w","type":"image/webp","sizes":"(min-width: 2268px) 2268px, 100vw"}]},"width":2268,"height":1134}},"publicURL":"/static/524d5d37d834bb1b9ad60ee4176eb8a9/clean_code_thumb.png"}}}}]}},"pageContext":{"slug":"/clean_code/2022-07-20-[Clean Code] 11장 정리/"}},"staticQueryHashes":[]}