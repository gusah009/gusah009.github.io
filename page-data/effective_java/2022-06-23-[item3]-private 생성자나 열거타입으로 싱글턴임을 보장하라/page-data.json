{"componentChunkName":"component---src-templates-post-template-tsx","path":"/effective_java/2022-06-23-[item3]-private 생성자나 열거타입으로 싱글턴임을 보장하라/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<blockquote>\n<p><strong>private 생성자나 열거타입으로 싱글턴임을 보장하라</strong></p>\n</blockquote>\n<p>저자는 싱글턴을 만들 때 private 생성자나 열거타입(enum)으로 만들길 권장하고 있습니다. 그 이유에 대해 알아보겠습니다.</p>\n<blockquote>\n<p><strong>싱글턴</strong>: 인스턴스를 오직 하나만 생성할 수 있는 클래스를 말한다.</p>\n</blockquote>\n<p>싱글턴을 만드는 방식엔 총 3가지가 있습니다.</p>\n<ol>\n<li><code class=\"language-text\">public static final</code> 필드 방식의 싱글턴</li>\n<li>정적 팩터리 메서드를 사용하는 방식의 싱글턴</li>\n<li><strong>열거 타입 방식의 싱글턴</strong></li>\n</ol>\n<p>결론부터 말씀드리면, 저자가 생각하는 가장 좋은 싱글턴 패턴은 <strong>열거 타입</strong>을 사용하는 것입니다. 위의 싱글턴을 만드는 방식에 대해 하나하나 알아보면서 각각 어떤 장단점이 있는 지 알아보겠습니다.</p>\n<h2>public static final 필드 방식의 싱글턴</h2>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MyDate</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">MyDate</span> <span class=\"token constant\">INSTANCE</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">MyDate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">private</span> <span class=\"token class-name\">MyDate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> <span class=\"token comment\">// private 생성자</span>\n\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">long</span> <span class=\"token function\">getNextMonth</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">private</code> 생성자는 <code class=\"language-text\">MyDate.INSTANCE</code>를 생성할 때 단 한번만 호출되고, <code class=\"language-text\">public</code>이나 <code class=\"language-text\">protected</code> 생성자가 없기 때문에 항상 시스템엔 <code class=\"language-text\">MyDate</code>의 객체가 하나임이 보장됩니다. 하지만 <code class=\"language-text\">setAccessible</code>이란 리플렉션 API를 사용하면 <code class=\"language-text\">private</code> 생성자를 호출할 수 있는데, 이 내용에 대해선 뒤에 배웁니다.</p>\n<h3>장점</h3>\n<p>해당 클래스가 싱글턴임이 API에 명백히 드러난다는 장점이 있습니다. public static 필드가 final이니 절대 다른 객체를 참조할 수 없음을 한 눈에 확인할 수 있습니다. 또 간결함이 가장 큰 장점입니다.</p>\n<h2>정적 팩터리 메서드 방식의 싱글턴</h2>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MyDate</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">MyDate</span> <span class=\"token constant\">INSTANCE</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">MyDate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">private</span> <span class=\"token class-name\">MyDate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> <span class=\"token comment\">// private 생성자</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">MyDate</span> <span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> <span class=\"token constant\">INSTANCE</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">long</span> <span class=\"token function\">getNextMonth</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">INSTANCE</code>가 <code class=\"language-text\">private</code>이기 때문에 이를 호출하는 방식은 <code class=\"language-text\">getInstance()</code>밖에 없습니다. 위와 무슨 차이가 있는거지? 하실 수 있기 때문에 아래에서 정적 팩터리 메서드 방식의 장점을 바로 살펴보겠습니다.</p>\n<h3>장점</h3>\n<p>위 방식의 장점은 마음이 바뀌면 API를 바꾸지 않고도 싱글턴이 아니게끔 변경할 수 있습니다. 클라이언트 코드에선 <code class=\"language-text\">getInstance()</code>로 instance를 불러오기 때문에 <strong>이게 싱글턴인지, 아니면 다른 어떤 객체인 지 알지 않아도 됩니다.</strong></p>\n<p>두 번째 장점은 원한다면 정적 팩터리를 제네릭 싱글턴 팩터리로 만들 수 있다는 점입니다. 제네릭 싱글턴 팩터리에 대해선 이후 <code class=\"language-text\">[item30]</code>에서 배웁니다.</p>\n<p>마지막 장점은 정적 팩터리 메서드 참조를 공급자(supplier)로 사용 할 수 있다는 점입니다. <code class=\"language-text\">Supplier&lt;INSTANCE></code>로도 쓸 수 있다는 장점이 있습니다.</p>\n<h3>위의 두 방식의 단점</h3>\n<p>하지만 위의 두 방식 모두 단점이 존재합니다. 바로 직렬화할 때의 문제인데, 보통 직렬화를 구현하기 위해 우리는 <code class=\"language-text\">Serializable</code> 인터페이스를 구현해 사용합니다. 하지만 이 방식만으로 객체를 직렬화하고, <strong>역직렬화해서 객체를 사용하게 되면 새로운 인스턴스가 만들어 집니다.</strong> 즉, 싱글턴이 보장되지 않는다는 것입니다. 이런 가짜 인스턴스를 막기 위한 방법이 존재하는데, 이는 이후 <code class=\"language-text\">[item89]</code>에서 살펴보겠습니다.</p>\n<h2>열거 타입 방식의 싱글턴</h2>\n<p>결국 저자가 권유하는 싱글턴 생성 방식은 열거타입(enum)입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">enum</span> <span class=\"token class-name\">MyDate</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token constant\">BIRTHDAY</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">HAPPY_DAY</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">long</span> <span class=\"token function\">getNextMonth</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>아래와 같이 특정 <code class=\"language-text\">Instance</code>를 싱글턴 형식으로 사용할 수 있으며, 앞서 봤던 단점들인 아주 복잡한 직렬화 상황이나 리플렉션 공격에서도 제2의 인스턴스가 생기는 일을 완벽히 막아줍니다. 저자는 <strong>부자연스러워 보일 순 있지만 대부분의 상황에서 원소가 하나뿐인 열거 타입이 싱글턴을 만드는 가장 좋은 방법</strong>이라고 말하고 있습니다.</p>\n<h3>단점</h3>\n<p>단, 만드려는 싱글턴이 Enum 외의 클래스를 상속해야 한다면 이 방법은 사용할 수 없다는 단점이 있습니다.</p>\n<h3>Ref.</h3>\n<p><a href=\"https://junha.tistory.com/25\" target=\"_blank\" rel=\"nofollow\">https://junha.tistory.com/25</a></p>","frontmatter":{"title":"[item3] private 생성자나 열거타입으로 싱글턴임을 보장하라","summary":"저자는 싱글턴을 만들 때 private 생성자나 열거타입(enum)으로 만들길 권장하고 있습니다. 그 이유에 대해 알아보겠습니다.","date":"2022.06.23.","categories":["effective_java"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAABYlAAAWJQFJUiTwAAACEUlEQVQ4y52S30/aUBSA+St998FnH3zxxZj45Bv/wpaYbW4mxmwwoTADTkdrS1UmY9PoNu2lLSKgtCj98S0tMHVD9+MmJ+c2+e537+k5idROj6XMEa+KFpLusq60Scttsjsd3mp9cvoV0u4NyxsGz/KnZMrXZNWIuSSjtEirN0i6Q27XJa15JHJ6j0JZZU05QVY+U/xQ5UX+lCerZZY3zyk2TQonNxTkA9bkMkVNIG8rrG7aLL3WeZr+Rl5c8N5sklZ9Euvla7Z2bCTNJqtfsFXpslq64uVmk4x2iXTQRdpzKOxdUdjvktO7bFc6rGsOz4tNUnIb6aMTR/zC4r7DhbrN4XGeyvdP1I0GZt3ENm3qwkKcWQjDxBAWhmEhhMmZYVEXQ6ZuY4o6R1/PSUVC+dBn3ArDgCAIoh1hGMb5dv/76rghb9Q+CfmLF4NBOIAjPAjGH7q9LGJHecC2nZ9C/w50C1SrVRRFodVqIYSg1+vRaDSwbXss/6BwUCaUSiXm5+eZmZlhenqaZDLJ4uIiExMTsZi4kuDPwtFaWVlhYWGBqakpZmdnmZycZG5uLhamUqmY8X3/74RRrtVqGIYRf7uuG5fe6XQGDRjmR0sO7v3o+w34tSF3GxOMhN2hUHlkbKKIx2X0kjvj8+DYbNU8fD+kPwzvH6PvDS6z2sFAmNb65Pc9Nioe7/4zorPZXY/I9QPmkQcBe3w4NQAAAABJRU5ErkJggg=="},"images":{"fallback":{"src":"/static/327c2a185475980ae96309d9334c4ac8/3e909/effective_java_thumb.png","srcSet":"/static/327c2a185475980ae96309d9334c4ac8/7f2ad/effective_java_thumb.png 204w,\n/static/327c2a185475980ae96309d9334c4ac8/db3cb/effective_java_thumb.png 408w,\n/static/327c2a185475980ae96309d9334c4ac8/3e909/effective_java_thumb.png 815w","sizes":"(min-width: 815px) 815px, 100vw"},"sources":[{"srcSet":"/static/327c2a185475980ae96309d9334c4ac8/2ff66/effective_java_thumb.webp 204w,\n/static/327c2a185475980ae96309d9334c4ac8/1f8c8/effective_java_thumb.webp 408w,\n/static/327c2a185475980ae96309d9334c4ac8/9fe5f/effective_java_thumb.webp 815w","type":"image/webp","sizes":"(min-width: 815px) 815px, 100vw"}]},"width":815,"height":559}},"publicURL":"/static/327c2a185475980ae96309d9334c4ac8/effective_java_thumb.png"}}}}]}},"pageContext":{"slug":"/effective_java/2022-06-23-[item3]-private 생성자나 열거타입으로 싱글턴임을 보장하라/"}},"staticQueryHashes":[]}