{"componentChunkName":"component---src-templates-post-template-tsx","path":"/effective_java/2022-07-12-[item17]-변경 가능성을 최소화하라/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<blockquote>\n<p><strong>변경 가능성을 최소화하라</strong></p>\n</blockquote>\n<p><code class=\"language-text\">Java</code>와 같은 멀티 스레드 환경에서 특히 중요한 파트인 것 같습니다. <strong>“변경 가능성을 최소화하라”</strong> 의 말 뜻은 <strong>“되도록이면 불변으로 객체를 설계해라”</strong> 로 받아들여도 될 것 같습니다.</p>\n<h2>불변 클래스</h2>\n<p>불변 클래스란 <strong>그 인스턴스의 내부 값을 수정할 수 없는 클래스</strong>입니다. 한 번 생성된 객체는 파괴될 때 까지 내부 정보가 바뀌지 않음을 보장합니다. <code class=\"language-text\">String</code>, 기본 타입의 박싱 클래스들, <code class=\"language-text\">BigInteger</code>, <code class=\"language-text\">BigDecimal</code>이 여기에 속합니다.</p>\n<p>불변 클래스로 만들기 위한 규약들이 있는데 이는 아래와 같습니다.</p>\n<p><strong>1. 객체의 상태를 변경하는 메서드를 제공하지 않는다.</strong>\n<strong>2. 클래스를 확장할 수 없도록 한다.</strong>\n<strong>3. 모든 필드들을 final로 선언한다.</strong>\n<strong>4. 모든 필드들을 private 접근제한자로 선언한다.</strong>\n<strong>5. 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.</strong></p>\n<p>하나씩 살펴보겠습니다.</p>\n<h3>1. 객체의 상태를 변경하는 메서드를 제공하지 않는다.</h3>\n<p>말 그대로 <code class=\"language-text\">setter</code>나 다른 상태를 변경할 수 있는 메서드를 제공하지 않음으로서 불변을 유지합니다.</p>\n<h3>2. 클래스를 확장할 수 없도록 한다.</h3>\n<p>아예 상속을 막음으로서 하위 클래스에서 실수로 불변을 깨는 불상사를 막아줍니다.</p>\n<h3>3.모든 필드들을 final로 선언한다.</h3>\n<p>시스템이 강제하는 수단을 이용해서 설계자의 의도를 명확히 드러내는 방법입니다. 새로 생성된 인스턴스가 동기화 없이 멀티 스레드 환경에서 문제 없이 동작함을 보장합니다.</p>\n<h3>4. 모든 필드들을 private 접근제한자로 선언한다.</h3>\n<p>필드가 참조하는 가변 객체를 클라이언트에서 직접 접근해 수정하는 일을 막아줍니다.</p>\n<h3>5. 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.</h3>\n<p>클래스에 가변 객체를 참조하는 필드가 하나라도 있다면 클라이언트에서 그 객체의 참조를 얻을 수 없게 해야 합니다. 이런 필드는 반드시 방어적 복사를 통해서 제공해야 합니다.</p>\n<h2>불변 객체의 장점</h2>\n<h3>스레드 안전</h3>\n<p>기본적으로 불변 클래스에서 값의 변경이 일어나면 새로운 객체를 생성해서 전달해줍니다. 이는 현재 객체는 반드시 불변이 보장됨을 의미하며 <strong>여러 스레드에서 동시에 사용돼도 문제 없다는 것을 의미합니다.</strong> 따라서 불변 클래스라면 한번 만든 인스턴스를 최대한 재활용하길 저자는 권하고 있습니다.</p>\n<h3>불변 객체의 캐싱 기능</h3>\n<p>불변 객체는 한 번 생성하여 여러 스레드에서 안전하게 사용 가능 합니다. 이는 <strong>캐싱 역할</strong>도 하여 성능 향상을 얻을 수 있다는 장점도 있으며 여러 스레드가 하나의 객체를 동시에 사용하기 때문에 <strong>메모리 사용량과 GC 비용을 줄일 수 있습니다.</strong></p>\n<h3>불변 객체끼리는 내부 데이터를 공유할 수 있다.</h3>\n<p>예를 들어, 필드에 배열이 있다고 가정해봅시다. 원래 불변 객체는 배열을 방어적 복사를 통해 새로 생성하여 전달하여야 하지만 배열 내부 정보가 바뀌지 않았고, 배열 역시 불변이 보장된다면, <strong>기존의 불변 객체와 배열을 공유하므로써 메모리를 아끼고, 성능의 향상을 누릴 수 있습니다.</strong></p>\n<h2>불변 객체의 단점</h2>\n<p>하지만 이런 불변 객체에도 단점은 존재합니다. 바로 값이 다르다면 <strong>반드시 독립된 객체로 만들어야 한다</strong>는 것입니다. 단 1bit만 달라도 새로운 객체를 생성해야 하므로 잦은 값 변경이 일어나는 불변 클래스는 성능 문제가 있을 수 밖에 없습니다.</p>\n<blockquote>\n<p>직렬화 시에 불변 클래스로부터 가변 인스턴스를 만들 수도 있다는 단점 역시 존재합니다. 이는 [item88]에서 다뤄보도록 하겠습니다.</p>\n</blockquote>\n<h2>요약</h2>\n<p><strong>합당한 이유가 없다면 단순한 값 클래스는 불변 클래스로 만드는 것이 좋습니다. 또, 불변 클래스의 생성자나 정적 팩터리는 불변식 설정이 모두 완료 된, 초기화가 완벽히 끝난 상태의 객체를 생성해야 합니다.</strong></p>\n<style class=\"grvsc-styles\">\n  .grvsc-container {\n    overflow: auto;\n    position: relative;\n    -webkit-overflow-scrolling: touch;\n    padding-top: 1rem;\n    padding-top: var(--grvsc-padding-top, var(--grvsc-padding-v, 1rem));\n    padding-bottom: 1rem;\n    padding-bottom: var(--grvsc-padding-bottom, var(--grvsc-padding-v, 1rem));\n    border-radius: 8px;\n    border-radius: var(--grvsc-border-radius, 8px);\n    font-feature-settings: normal;\n    line-height: 1.4;\n  }\n  \n  .grvsc-code {\n    display: table;\n  }\n  \n  .grvsc-line {\n    display: table-row;\n    box-sizing: border-box;\n    width: 100%;\n    position: relative;\n  }\n  \n  .grvsc-line > * {\n    position: relative;\n  }\n  \n  .grvsc-gutter-pad {\n    display: table-cell;\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  .grvsc-gutter {\n    display: table-cell;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter::before {\n    content: attr(data-content);\n  }\n  \n  .grvsc-source {\n    display: table-cell;\n    padding-left: 1.5rem;\n    padding-left: var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem));\n    padding-right: 1.5rem;\n    padding-right: var(--grvsc-padding-right, var(--grvsc-padding-h, 1.5rem));\n  }\n  \n  .grvsc-source:empty::after {\n    content: ' ';\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter + .grvsc-source {\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  /* Line transformer styles */\n  \n  .grvsc-has-line-highlighting > .grvsc-code > .grvsc-line::before {\n    content: ' ';\n    position: absolute;\n    width: 100%;\n  }\n  \n  .grvsc-line-diff-add::before {\n    background-color: var(--grvsc-line-diff-add-background-color, rgba(0, 255, 60, 0.2));\n  }\n  \n  .grvsc-line-diff-del::before {\n    background-color: var(--grvsc-line-diff-del-background-color, rgba(255, 0, 20, 0.2));\n  }\n  \n  .grvsc-line-number {\n    padding: 0 2px;\n    text-align: right;\n    opacity: 0.7;\n  }\n  \n</style>","frontmatter":{"title":"[item17] 변경 가능성을 최소화하라","summary":"`Java`와 같은 멀티 스레드 환경에서 특히 중요한 파트인 것 같습니다. \"변경 가능성을 최소화하라\"의 말 뜻은 \"되도록이면 불변으로 객체를 설계해라\"로 받아들여도 될 것 같습니다.","date":"2022.07.12.","categories":["effective_java"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAABYlAAAWJQFJUiTwAAACEUlEQVQ4y52S30/aUBSA+St998FnH3zxxZj45Bv/wpaYbW4mxmwwoTADTkdrS1UmY9PoNu2lLSKgtCj98S0tMHVD9+MmJ+c2+e537+k5idROj6XMEa+KFpLusq60Scttsjsd3mp9cvoV0u4NyxsGz/KnZMrXZNWIuSSjtEirN0i6Q27XJa15JHJ6j0JZZU05QVY+U/xQ5UX+lCerZZY3zyk2TQonNxTkA9bkMkVNIG8rrG7aLL3WeZr+Rl5c8N5sklZ9Euvla7Z2bCTNJqtfsFXpslq64uVmk4x2iXTQRdpzKOxdUdjvktO7bFc6rGsOz4tNUnIb6aMTR/zC4r7DhbrN4XGeyvdP1I0GZt3ENm3qwkKcWQjDxBAWhmEhhMmZYVEXQ6ZuY4o6R1/PSUVC+dBn3ArDgCAIoh1hGMb5dv/76rghb9Q+CfmLF4NBOIAjPAjGH7q9LGJHecC2nZ9C/w50C1SrVRRFodVqIYSg1+vRaDSwbXss/6BwUCaUSiXm5+eZmZlhenqaZDLJ4uIiExMTsZi4kuDPwtFaWVlhYWGBqakpZmdnmZycZG5uLhamUqmY8X3/74RRrtVqGIYRf7uuG5fe6XQGDRjmR0sO7v3o+w34tSF3GxOMhN2hUHlkbKKIx2X0kjvj8+DYbNU8fD+kPwzvH6PvDS6z2sFAmNb65Pc9Nioe7/4zorPZXY/I9QPmkQcBe3w4NQAAAABJRU5ErkJggg=="},"images":{"fallback":{"src":"/static/327c2a185475980ae96309d9334c4ac8/3e909/effective_java_thumb.png","srcSet":"/static/327c2a185475980ae96309d9334c4ac8/7f2ad/effective_java_thumb.png 204w,\n/static/327c2a185475980ae96309d9334c4ac8/db3cb/effective_java_thumb.png 408w,\n/static/327c2a185475980ae96309d9334c4ac8/3e909/effective_java_thumb.png 815w","sizes":"(min-width: 815px) 815px, 100vw"},"sources":[{"srcSet":"/static/327c2a185475980ae96309d9334c4ac8/2ff66/effective_java_thumb.webp 204w,\n/static/327c2a185475980ae96309d9334c4ac8/1f8c8/effective_java_thumb.webp 408w,\n/static/327c2a185475980ae96309d9334c4ac8/9fe5f/effective_java_thumb.webp 815w","type":"image/webp","sizes":"(min-width: 815px) 815px, 100vw"}]},"width":815,"height":559}},"publicURL":"/static/327c2a185475980ae96309d9334c4ac8/effective_java_thumb.png"}}}}]}},"pageContext":{"slug":"/effective_java/2022-07-12-[item17]-변경 가능성을 최소화하라/"}},"staticQueryHashes":[]}