{"componentChunkName":"component---src-templates-post-template-tsx","path":"/effective_java/2022-08-17-[item48]-스트림 병렬화는 주의해서 적용하라/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<blockquote>\n<p><strong>스트림 병렬화는 주의해서 적용하라</strong></p>\n</blockquote>\n<p>자바는 스트림을 지원하면서 동시에 <strong>병렬 연산이 가능한 스트림</strong>인 <code class=\"language-text\">parallel stream</code>을 지원했습니다. 병렬 스트림 파이프라인은 충분히 직관적이고 쉬운 기술이지만 <strong>자칫 잘못하면 최악의 결과</strong>를 낳을 수 있습니다. 그 이유에 대해서 살펴보겠습니다.</p>\n<h2>parallel과 limit</h2>\n<p>책에서 메르센 소수를 구하는 방법으로 <code class=\"language-text\">parallel stream</code>과  <code class=\"language-text\">limit</code>를 사용했을 때 더 느려지는 것을 보여주고 있습니다. 그 이유는 바로 <code class=\"language-text\">limit</code>에 있는데, 옮긴이가 아주 잘 설명해주고 있습니다.</p>\n<p>옮긴이의 말을 빌리자면, <code class=\"language-text\">limit</code>를 다룰 때 CPU 코어가 남으면 해당 코어를 모두 사용해 버립니다.</p>\n<pre class=\"grvsc-container default-dark\" data-language=\"java\" data-index=\"0\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">public</span><span class=\"mtk1\"> </span><span class=\"mtk4\">static</span><span class=\"mtk1\"> </span><span class=\"mtk10\">void</span><span class=\"mtk1\"> </span><span class=\"mtk11\">main</span><span class=\"mtk1\">(</span><span class=\"mtk10\">String</span><span class=\"mtk1\">[] args) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk11\">primes</span><span class=\"mtk1\">().</span><span class=\"mtk11\">map</span><span class=\"mtk1\">(p </span><span class=\"mtk4\">-&gt;</span><span class=\"mtk1\"> </span><span class=\"mtk12\">TWO</span><span class=\"mtk1\">.</span><span class=\"mtk11\">pow</span><span class=\"mtk1\">(</span><span class=\"mtk12\">p</span><span class=\"mtk1\">.</span><span class=\"mtk11\">intValueExact</span><span class=\"mtk1\">()).</span><span class=\"mtk11\">subtract</span><span class=\"mtk1\">(ONE))</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">      .</span><span class=\"mtk11\">filter</span><span class=\"mtk1\">(mersenne </span><span class=\"mtk4\">-&gt;</span><span class=\"mtk1\"> </span><span class=\"mtk12\">mersenne</span><span class=\"mtk1\">.</span><span class=\"mtk11\">isProbablePrime</span><span class=\"mtk1\">(</span><span class=\"mtk7\">50</span><span class=\"mtk1\">))</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">      .</span><span class=\"mtk11\">limit</span><span class=\"mtk1\">(</span><span class=\"mtk7\">20</span><span class=\"mtk1\">)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">      .</span><span class=\"mtk11\">forEach</span><span class=\"mtk1\">(</span><span class=\"mtk12\">System</span><span class=\"mtk1\">.</span><span class=\"mtk12\">out</span><span class=\"mtk15\">::</span><span class=\"mtk1\">println);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">static</span><span class=\"mtk1\"> </span><span class=\"mtk10\">Stream</span><span class=\"mtk1\">&lt;BigInteger&gt; </span><span class=\"mtk11\">primes</span><span class=\"mtk1\">() {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk12\">Stream</span><span class=\"mtk1\">.</span><span class=\"mtk11\">iterate</span><span class=\"mtk1\">(TWO, BigInteger</span><span class=\"mtk15\">::</span><span class=\"mtk1\">nextProbablePrime);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<p>단적인 예로 코어가 4개인 CPU에서 <code class=\"language-text\">limit(20)</code>으로 20번째 메르센 소수를 찾도록 했다고 가정해보겠습니다. 만약 20번째 메르센 소수를 찾는데 코어가 4개가 남아있다면, 20번째, 21번째, 22번째, 23번째 총 4개의 메르센 소수를 추가로 찾도록 CPU에게 명령을 내려버립니다. (찾아졌을 때 21, 22, 23번째 소수는 버리면 되기 때문)</p>\n<p>그래서 <strong>단순히 20번째 메르센 소수를 찾고 끝날 일</strong>이 최악의 경우에 이토록 오래 걸리게 되는 것입니다.</p>\n<p>이처럼 자동 병렬화 파이프라인이 최적화시킬 방법을 못찾는 경우 오히려 더 느려진다는 것을 알 수 있습니다.</p>\n<h2>병렬처리에 좋은 스트림 소스</h2>\n<p>병렬처리에 좋은 스트림 소스론 대체로 <code class=\"language-text\">ArrayList</code>, <code class=\"language-text\">HashSet</code>, <code class=\"language-text\">ConcurrentHashMap</code>, 배열, int 범위, long 범위가 있습니다. 그 이유는 바로 데이터를 원하는 크기로 정확하게 나누고 분배할 수 있어서 다수의 스레드에 분배하기 좋기 때문입니다.</p>\n<p>또 위 자료구조들의 공통점은 원소들을 순차적으로 실행할 때의 <strong>참조 지역성</strong>이 뛰어나다는 것입니다. 이웃한 원소의 참조들이 메모리에 연속해서 저장되어 있기 때문에 메모리로부터 캐시로 원소들을 가져올 때 빠르다는 장점이 있습니다.</p>\n<blockquote>\n<p>물론 참조들이 가리키는 실제 객체가 <strong>메모리에서 서로 떨어져 있을 수</strong> 있는데, 그러면 <strong>참조 지역성이 나빠져</strong> 성능이 나빠집니다. <strong>기본 타입 배열</strong>은 항상 메모리에 연속해서 저장되기 때문에 참조 지역성이 가장 뛰어납니다.</p>\n</blockquote>\n<h2>병렬처리에 좋은 종단 연산</h2>\n<p>병렬처리에 좋은 종단 연산으론 <code class=\"language-text\">reduce</code>, <code class=\"language-text\">min</code>, <code class=\"language-text\">max</code>, <code class=\"language-text\">count</code>, <code class=\"language-text\">sum</code>, <code class=\"language-text\">anyMatch</code>, <code class=\"language-text\">allMatch</code>, <code class=\"language-text\">noneMatch</code>가 있습니다.</p>\n<h2>스트림 병렬화는 주의해서 적용하라</h2>\n<p>스트림 병렬화가 주는 장점이 많음에도 불구하고 이 장의 제목처럼 <strong>스트림 병렬화는 주의해서 사용해야 합니다.</strong> 스트림을 잘못 병렬화하면 처음 예시처럼 성능이 나빠질 수도 있고, 더 나아가서 결과 자체가 잘못되거나 예상치 못한 동작이 발생할 수 있습니다.</p>\n<p>실제 위의 메르센 소수를 병렬 스트림으로 구하는 예시에서 완료되더라도 소수를 발견한 순서대로 출력되지 않을 수 있습니다.</p>\n<p>심지어 데이터 소스 스트림이 효율적으로 나뉘어지고, 병렬화하거나 빨리 끝나는 종단 연산을 사용하고, 함수 객체들도 간섭하지 않더라도 <strong>병렬화 자체에 드는 비용을 상쇄시키지 못하면</strong> 성능 향상은 미미할 수 있습니다.</p>\n<h2>결론</h2>\n<p>그러므로 계산도 올바로 수행하고 성능도 빨라질 거라는 <strong>확신 없이는 병렬 스트림은 시도조차 하지 말도록</strong> 합시다. 병렬화하는 편이 낫다고 믿더라도, 테스트를 꾸준히 해보고 성능 지표를 유심하게 살펴봐야 합니다. 계산도 정확하고 성능이 좋아졌음이 확실해졌을 때에만 병렬화 버전 코드를 운영 코드에 반영합시다.</p>\n<style class=\"grvsc-styles\">\n  .grvsc-container {\n    overflow: auto;\n    position: relative;\n    -webkit-overflow-scrolling: touch;\n    padding-top: 1rem;\n    padding-top: var(--grvsc-padding-top, var(--grvsc-padding-v, 1rem));\n    padding-bottom: 1rem;\n    padding-bottom: var(--grvsc-padding-bottom, var(--grvsc-padding-v, 1rem));\n    border-radius: 8px;\n    border-radius: var(--grvsc-border-radius, 8px);\n    font-feature-settings: normal;\n    line-height: 1.4;\n  }\n  \n  .grvsc-code {\n    display: table;\n  }\n  \n  .grvsc-line {\n    display: table-row;\n    box-sizing: border-box;\n    width: 100%;\n    position: relative;\n  }\n  \n  .grvsc-line > * {\n    position: relative;\n  }\n  \n  .grvsc-gutter-pad {\n    display: table-cell;\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  .grvsc-gutter {\n    display: table-cell;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter::before {\n    content: attr(data-content);\n  }\n  \n  .grvsc-source {\n    display: table-cell;\n    padding-left: 1.5rem;\n    padding-left: var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem));\n    padding-right: 1.5rem;\n    padding-right: var(--grvsc-padding-right, var(--grvsc-padding-h, 1.5rem));\n  }\n  \n  .grvsc-source:empty::after {\n    content: ' ';\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter + .grvsc-source {\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  /* Line transformer styles */\n  \n  .grvsc-has-line-highlighting > .grvsc-code > .grvsc-line::before {\n    content: ' ';\n    position: absolute;\n    width: 100%;\n  }\n  \n  .grvsc-line-diff-add::before {\n    background-color: var(--grvsc-line-diff-add-background-color, rgba(0, 255, 60, 0.2));\n  }\n  \n  .grvsc-line-diff-del::before {\n    background-color: var(--grvsc-line-diff-del-background-color, rgba(255, 0, 20, 0.2));\n  }\n  \n  .grvsc-line-number {\n    padding: 0 2px;\n    text-align: right;\n    opacity: 0.7;\n  }\n  \n  .default-dark {\n    background-color: #1E1E1E;\n    color: #D4D4D4;\n  }\n  .default-dark .mtk4 { color: #569CD6; }\n  .default-dark .mtk1 { color: #D4D4D4; }\n  .default-dark .mtk10 { color: #4EC9B0; }\n  .default-dark .mtk11 { color: #DCDCAA; }\n  .default-dark .mtk12 { color: #9CDCFE; }\n  .default-dark .mtk7 { color: #B5CEA8; }\n  .default-dark .mtk15 { color: #C586C0; }\n  .default-dark .grvsc-line-highlighted::before {\n    background-color: var(--grvsc-line-highlighted-background-color, rgba(255, 255, 255, 0.1));\n    box-shadow: inset var(--grvsc-line-highlighted-border-width, 4px) 0 0 0 var(--grvsc-line-highlighted-border-color, rgba(255, 255, 255, 0.5));\n  }\n</style>","frontmatter":{"title":"[item48] 스트림 병렬화는 주의해서 적용하라","summary":"자바는 스트림을 지원하면서 동시에 병렬 연산이 가능한 스트림인 `parallel stream`을 지원했습니다. 병렬 스트림 파이프라인은 충분히 직관적이고 쉬운 기술이지만 자칫 잘못하면 최악의 결과를 낳을 수 있습니다. 그 이유에 대해서 살펴보겠습니다.","date":"2022.08.17.","categories":["effective_java"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAABYlAAAWJQFJUiTwAAACEUlEQVQ4y52S30/aUBSA+St998FnH3zxxZj45Bv/wpaYbW4mxmwwoTADTkdrS1UmY9PoNu2lLSKgtCj98S0tMHVD9+MmJ+c2+e537+k5idROj6XMEa+KFpLusq60Scttsjsd3mp9cvoV0u4NyxsGz/KnZMrXZNWIuSSjtEirN0i6Q27XJa15JHJ6j0JZZU05QVY+U/xQ5UX+lCerZZY3zyk2TQonNxTkA9bkMkVNIG8rrG7aLL3WeZr+Rl5c8N5sklZ9Euvla7Z2bCTNJqtfsFXpslq64uVmk4x2iXTQRdpzKOxdUdjvktO7bFc6rGsOz4tNUnIb6aMTR/zC4r7DhbrN4XGeyvdP1I0GZt3ENm3qwkKcWQjDxBAWhmEhhMmZYVEXQ6ZuY4o6R1/PSUVC+dBn3ArDgCAIoh1hGMb5dv/76rghb9Q+CfmLF4NBOIAjPAjGH7q9LGJHecC2nZ9C/w50C1SrVRRFodVqIYSg1+vRaDSwbXss/6BwUCaUSiXm5+eZmZlhenqaZDLJ4uIiExMTsZi4kuDPwtFaWVlhYWGBqakpZmdnmZycZG5uLhamUqmY8X3/74RRrtVqGIYRf7uuG5fe6XQGDRjmR0sO7v3o+w34tSF3GxOMhN2hUHlkbKKIx2X0kjvj8+DYbNU8fD+kPwzvH6PvDS6z2sFAmNb65Pc9Nioe7/4zorPZXY/I9QPmkQcBe3w4NQAAAABJRU5ErkJggg=="},"images":{"fallback":{"src":"/static/327c2a185475980ae96309d9334c4ac8/3e909/effective_java_thumb.png","srcSet":"/static/327c2a185475980ae96309d9334c4ac8/7f2ad/effective_java_thumb.png 204w,\n/static/327c2a185475980ae96309d9334c4ac8/db3cb/effective_java_thumb.png 408w,\n/static/327c2a185475980ae96309d9334c4ac8/3e909/effective_java_thumb.png 815w","sizes":"(min-width: 815px) 815px, 100vw"},"sources":[{"srcSet":"/static/327c2a185475980ae96309d9334c4ac8/2ff66/effective_java_thumb.webp 204w,\n/static/327c2a185475980ae96309d9334c4ac8/1f8c8/effective_java_thumb.webp 408w,\n/static/327c2a185475980ae96309d9334c4ac8/9fe5f/effective_java_thumb.webp 815w","type":"image/webp","sizes":"(min-width: 815px) 815px, 100vw"}]},"width":815,"height":559}},"publicURL":"/static/327c2a185475980ae96309d9334c4ac8/effective_java_thumb.png"}}}}]}},"pageContext":{"slug":"/effective_java/2022-08-17-[item48]-스트림 병렬화는 주의해서 적용하라/"}},"staticQueryHashes":[]}