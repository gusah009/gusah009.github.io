{"componentChunkName":"component---src-templates-post-template-tsx","path":"/effective_java/2022-08-17-[item48]-스트림 병렬화는 주의해서 적용하라/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<blockquote>\n<p><strong>스트림 병렬화는 주의해서 적용하라</strong></p>\n</blockquote>\n<p>자바는 스트림을 지원하면서 동시에 <strong>병렬 연산이 가능한 스트림</strong>인 <code class=\"language-text\">parallel stream</code>을 지원했습니다. 병렬 스트림 파이프라인은 충분히 직관적이고 쉬운 기술이지만 <strong>자칫 잘못하면 최악의 결과</strong>를 낳을 수 있습니다. 그 이유에 대해서 살펴보겠습니다.</p>\n<h2>parallel과 limit</h2>\n<p>책에서 메르센 소수를 구하는 방법으로 <code class=\"language-text\">parallel stream</code>과  <code class=\"language-text\">limit</code>를 사용했을 때 더 느려지는 것을 보여주고 있습니다. 그 이유는 바로 <code class=\"language-text\">limit</code>에 있는데, 옮긴이가 아주 잘 설명해주고 있습니다.</p>\n<p>옮긴이의 말을 빌리자면, <code class=\"language-text\">limit</code>를 다룰 때 CPU 코어가 남으면 해당 코어를 모두 사용해 버립니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">primes</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>p <span class=\"token operator\">-></span> <span class=\"token constant\">TWO</span><span class=\"token punctuation\">.</span><span class=\"token function\">pow</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">.</span><span class=\"token function\">intValueExact</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">subtract</span><span class=\"token punctuation\">(</span><span class=\"token constant\">ONE</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span>mersenne <span class=\"token operator\">-></span> mersenne<span class=\"token punctuation\">.</span><span class=\"token function\">isProbablePrime</span><span class=\"token punctuation\">(</span><span class=\"token number\">50</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">.</span><span class=\"token function\">limit</span><span class=\"token punctuation\">(</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token operator\">::</span><span class=\"token function\">println</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">static</span> <span class=\"token class-name\">Stream</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">BigInteger</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">primes</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token class-name\">Stream</span><span class=\"token punctuation\">.</span><span class=\"token function\">iterate</span><span class=\"token punctuation\">(</span><span class=\"token constant\">TWO</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">BigInteger</span><span class=\"token operator\">::</span><span class=\"token function\">nextProbablePrime</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>단적인 예로 코어가 4개인 CPU에서 <code class=\"language-text\">limit(20)</code>으로 20번째 메르센 소수를 찾도록 했다고 가정해보겠습니다. 만약 20번째 메르센 소수를 찾는데 코어가 4개가 남아있다면, 20번째, 21번째, 22번째, 23번째 총 4개의 메르센 소수를 추가로 찾도록 CPU에게 명령을 내려버립니다. (찾아졌을 때 21, 22, 23번째 소수는 버리면 되기 때문)</p>\n<p>그래서 <strong>단순히 20번째 메르센 소수를 찾고 끝날 일</strong>이 최악의 경우에 이토록 오래 걸리게 되는 것입니다.</p>\n<p>이처럼 자동 병렬화 파이프라인이 최적화시킬 방법을 못찾는 경우 오히려 더 느려진다는 것을 알 수 있습니다.</p>\n<h2>병렬처리에 좋은 스트림 소스</h2>\n<p>병렬처리에 좋은 스트림 소스론 대체로 <code class=\"language-text\">ArrayList</code>, <code class=\"language-text\">HashSet</code>, <code class=\"language-text\">ConcurrentHashMap</code>, 배열, int 범위, long 범위가 있습니다. 그 이유는 바로 데이터를 원하는 크기로 정확하게 나누고 분배할 수 있어서 다수의 스레드에 분배하기 좋기 때문입니다.</p>\n<p>또 위 자료구조들의 공통점은 원소들을 순차적으로 실행할 때의 <strong>참조 지역성</strong>이 뛰어나다는 것입니다. 이웃한 원소의 참조들이 메모리에 연속해서 저장되어 있기 때문에 메모리로부터 캐시로 원소들을 가져올 때 빠르다는 장점이 있습니다.</p>\n<blockquote>\n<p>물론 참조들이 가리키는 실제 객체가 <strong>메모리에서 서로 떨어져 있을 수</strong> 있는데, 그러면 <strong>참조 지역성이 나빠져</strong> 성능이 나빠집니다. <strong>기본 타입 배열</strong>은 항상 메모리에 연속해서 저장되기 때문에 참조 지역성이 가장 뛰어납니다.</p>\n</blockquote>\n<h2>병렬처리에 좋은 종단 연산</h2>\n<p>병렬처리에 좋은 종단 연산으론 <code class=\"language-text\">reduce</code>, <code class=\"language-text\">min</code>, <code class=\"language-text\">max</code>, <code class=\"language-text\">count</code>, <code class=\"language-text\">sum</code>, <code class=\"language-text\">anyMatch</code>, <code class=\"language-text\">allMatch</code>, <code class=\"language-text\">noneMatch</code>가 있습니다.</p>\n<h2>스트림 병렬화는 주의해서 적용하라</h2>\n<p>스트림 병렬화가 주는 장점이 많음에도 불구하고 이 장의 제목처럼 <strong>스트림 병렬화는 주의해서 사용해야 합니다.</strong> 스트림을 잘못 병렬화하면 처음 예시처럼 성능이 나빠질 수도 있고, 더 나아가서 결과 자체가 잘못되거나 예상치 못한 동작이 발생할 수 있습니다.</p>\n<p>실제 위의 메르센 소수를 병렬 스트림으로 구하는 예시에서 완료되더라도 소수를 발견한 순서대로 출력되지 않을 수 있습니다.</p>\n<p>심지어 데이터 소스 스트림이 효율적으로 나뉘어지고, 병렬화하거나 빨리 끝나는 종단 연산을 사용하고, 함수 객체들도 간섭하지 않더라도 <strong>병렬화 자체에 드는 비용을 상쇄시키지 못하면</strong> 성능 향상은 미미할 수 있습니다.</p>\n<h2>결론</h2>\n<p>그러므로 계산도 올바로 수행하고 성능도 빨라질 거라는 <strong>확신 없이는 병렬 스트림은 시도조차 하지 말도록</strong> 합시다. 병렬화하는 편이 낫다고 믿더라도, 테스트를 꾸준히 해보고 성능 지표를 유심하게 살펴봐야 합니다. 계산도 정확하고 성능이 좋아졌음이 확실해졌을 때에만 병렬화 버전 코드를 운영 코드에 반영합시다.</p>","frontmatter":{"title":"[item48] 스트림 병렬화는 주의해서 적용하라","summary":"자바는 스트림을 지원하면서 동시에 병렬 연산이 가능한 스트림인 `parallel stream`을 지원했습니다. 병렬 스트림 파이프라인은 충분히 직관적이고 쉬운 기술이지만 자칫 잘못하면 최악의 결과를 낳을 수 있습니다. 그 이유에 대해서 살펴보겠습니다.","date":"2022.08.17.","categories":["effective_java"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAABYlAAAWJQFJUiTwAAACEUlEQVQ4y52S30/aUBSA+St998FnH3zxxZj45Bv/wpaYbW4mxmwwoTADTkdrS1UmY9PoNu2lLSKgtCj98S0tMHVD9+MmJ+c2+e537+k5idROj6XMEa+KFpLusq60Scttsjsd3mp9cvoV0u4NyxsGz/KnZMrXZNWIuSSjtEirN0i6Q27XJa15JHJ6j0JZZU05QVY+U/xQ5UX+lCerZZY3zyk2TQonNxTkA9bkMkVNIG8rrG7aLL3WeZr+Rl5c8N5sklZ9Euvla7Z2bCTNJqtfsFXpslq64uVmk4x2iXTQRdpzKOxdUdjvktO7bFc6rGsOz4tNUnIb6aMTR/zC4r7DhbrN4XGeyvdP1I0GZt3ENm3qwkKcWQjDxBAWhmEhhMmZYVEXQ6ZuY4o6R1/PSUVC+dBn3ArDgCAIoh1hGMb5dv/76rghb9Q+CfmLF4NBOIAjPAjGH7q9LGJHecC2nZ9C/w50C1SrVRRFodVqIYSg1+vRaDSwbXss/6BwUCaUSiXm5+eZmZlhenqaZDLJ4uIiExMTsZi4kuDPwtFaWVlhYWGBqakpZmdnmZycZG5uLhamUqmY8X3/74RRrtVqGIYRf7uuG5fe6XQGDRjmR0sO7v3o+w34tSF3GxOMhN2hUHlkbKKIx2X0kjvj8+DYbNU8fD+kPwzvH6PvDS6z2sFAmNb65Pc9Nioe7/4zorPZXY/I9QPmkQcBe3w4NQAAAABJRU5ErkJggg=="},"images":{"fallback":{"src":"/static/327c2a185475980ae96309d9334c4ac8/3e909/effective_java_thumb.png","srcSet":"/static/327c2a185475980ae96309d9334c4ac8/7f2ad/effective_java_thumb.png 204w,\n/static/327c2a185475980ae96309d9334c4ac8/db3cb/effective_java_thumb.png 408w,\n/static/327c2a185475980ae96309d9334c4ac8/3e909/effective_java_thumb.png 815w","sizes":"(min-width: 815px) 815px, 100vw"},"sources":[{"srcSet":"/static/327c2a185475980ae96309d9334c4ac8/2ff66/effective_java_thumb.webp 204w,\n/static/327c2a185475980ae96309d9334c4ac8/1f8c8/effective_java_thumb.webp 408w,\n/static/327c2a185475980ae96309d9334c4ac8/9fe5f/effective_java_thumb.webp 815w","type":"image/webp","sizes":"(min-width: 815px) 815px, 100vw"}]},"width":815,"height":559}},"publicURL":"/static/327c2a185475980ae96309d9334c4ac8/effective_java_thumb.png"}}}}]}},"pageContext":{"slug":"/effective_java/2022-08-17-[item48]-스트림 병렬화는 주의해서 적용하라/"}},"staticQueryHashes":[]}