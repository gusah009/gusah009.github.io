{"componentChunkName":"component---src-templates-post-template-tsx","path":"/effective_java/2022-07-07-[item13]-clone 재정의는 주의해서 진행하라/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<blockquote>\n<p><strong>clone 재정의는 주의해서 진행하라</strong></p>\n</blockquote>\n<p><code class=\"language-text\">Java</code>에서는 <code class=\"language-text\">Cloneable</code>이라는 인터페이스를 제공합니다. 열어보면 아무 메서드도 제공하지 않는 이 인터페이스는 <code class=\"language-text\">Object</code>객체의 <code class=\"language-text\">clone()</code>을 활성화해주는 역할을 합니다. 저자는 <code class=\"language-text\">clone()</code> 메서드가 선언된 곳이 <code class=\"language-text\">Cloneable</code>이 아니라 <code class=\"language-text\">Object</code>에 있다는 점, 그리고 <code class=\"language-text\">protected</code>로 선언되어 있다는 점이 가장 큰 문제라고 말하고 있습니다. <strong>지금부터 <code class=\"language-text\">Clonable</code>의 문제점, 잘 동작하게끔 하는 사용법, 그리고 다른 선택지에 대해서 알아보겠습니다.</strong></p>\n<h2>일반적이지 않은 인터페이스 <code class=\"language-text\">Cloneable</code></h2>\n<p>보통 일반적으로 인터페이스를 구현한다고 하는 것은 해당 클래스가 그 인터페이스에서 정의한 기능을 제공한다고 선언하는 행위입니다. 하지만 이례적으로 <code class=\"language-text\">Cloneable</code>은 다르게 동작합니다. <code class=\"language-text\">Cloneable</code>을 구현한 클래스의 인스턴스에서 <strong><code class=\"language-text\">clone()</code>을 호출하면 그 객체들의 필드를 하나하나 복사해 줍니다.</strong></p>\n<blockquote>\n<p><code class=\"language-text\">Object</code>클래스의 <code class=\"language-text\">clone()</code>을 살펴보면 확실히 이례적임을 알 수 있습니다. 저자 역시 함부로 이런 인터페이스 사용 방식을 따라하지 말라고 하고 있습니다.</p>\n</blockquote>\n<h2>허술한 프로토콜 <code class=\"language-text\">clone()</code></h2>\n<p>하지만 이렇게 잘 복사될 것이라는 믿음과 다르게 <strong>잘 복사하는 것이 쉽지 않습니다.</strong> 그 이유는 바로 <code class=\"language-text\">super.clone()</code>에 있습니다. 아래의 예시를 보겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token keyword\">public</span> <span class=\"token class-name\">A</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>a <span class=\"token operator\">=</span> a<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">int</span> a<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">public</span> <span class=\"token class-name\">A</span> <span class=\"token function\">clone</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">A</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">B</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">A</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Cloneable</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token keyword\">int</span> b<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">public</span> <span class=\"token class-name\">B</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>b <span class=\"token operator\">=</span> b<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token annotation punctuation\">@Override</span>\n  <span class=\"token keyword\">public</span> <span class=\"token class-name\">B</span> <span class=\"token function\">clone</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">B</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">clone</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위 코드는 <code class=\"language-text\">A</code>라는 클래스를 상속받은 <code class=\"language-text\">B</code>클래스가 <code class=\"language-text\">clone()</code>을 재정의한 모습입니다. 하지만 함정이 있습니다. <code class=\"language-text\">B</code>클래스를 구현한 사람은 <code class=\"language-text\">A</code>클래스가 당연히 <code class=\"language-text\">Object</code>의 <code class=\"language-text\">clone()</code>을 재정의한 줄 알았겠지만 그렇지 않았습니다. <strong>이 경우에 컴파일러는 문제를 알아차릴 수 없고, 런타임시에 가서야 문제를 발견할 수 있습니다.</strong></p>\n<blockquote>\n<p>저자는 위와 같은 문제가 발생하지 않기 위해서는 반드시 규약에 따라 <code class=\"language-text\">super.clone()</code>으로 재정의하길 권장하고 있습니다. 혹은 <code class=\"language-text\">final</code>을 선언하여 상속문제가 생기지 않도록 하길 권장하고 있습니다. <strong>지금 이 문제만 봐도 저자가 우려하던 대로 <code class=\"language-text\">clone</code>이 강제할 수 없는 허술한 규약임을 알 수 있습니다.</strong></p>\n</blockquote>\n<h2>얕은 복사</h2>\n<p><code class=\"language-text\">clone()</code>메서드는 안타깝게도 깊은 복사를 해주지 않습니다. 배열 안에 있는 원소들을 각각 복사해주지 않고 참조 값만 복사하기 때문에 <code class=\"language-text\">Collection</code>에서 <code class=\"language-text\">super.clone()</code>만으로 복사를 하게 된다면, 복사 된 두 <code class=\"language-text\">Collection</code>이 원소를 공유하고 불변식을 해칩니다.</p>\n<p>이를 해결하기 위해선 각 원소에 대해 <code class=\"language-text\">clone()</code>을 재귀적으로 호출해주어야 합니다.</p>\n<h2>위와 같이 할 바엔 복사 생성자나 복사 팩터리를 사용하자!</h2>\n<p>저자는 이미 <code class=\"language-text\">Cloneable</code>을 구현한 클래스를 확장하려는 게 아니라면, <strong>복사 생성자와 복사 팩터리라는 더 나은 객체 복사 방식을 사용하길 권장하고 있습니다.</strong> 실제로 <code class=\"language-text\">Collection</code> 구현체에선 <code class=\"language-text\">Collection</code>이나 <code class=\"language-text\">Map</code> 타입을 받는 생성자를 제공합니다. <code class=\"language-text\">HashSet</code>을 보겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token class-name\">HashSet</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collection</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span> c<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  map <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Math</span><span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">/</span><span class=\"token number\">.75f</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">16</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">addAll</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">Collection</code>타입을 받는 생성자를 제공하고 있음을 볼 수 있습니다. 이는 곧 어떤 <code class=\"language-text\">Collection</code>이 들어와도 <code class=\"language-text\">HashSet</code>의 스타일로 바꿔준다는 것을 알 수 있습니다.</p>\n<h2>요약</h2>\n<p><code class=\"language-text\">Cloneable</code>의 문제를 보았을 때, 앞으로 생성할 클래스에는 절대 <code class=\"language-text\">Cloneable</code>을 구현해선 안됩니다. (성능 최적화 관점 제외) 기본 원칙은 “복사 생성자나 복사 팩터리를 사용하는게 최고”라는 것입니다. <strong>하지만 primitive 배열 만은 clone 메서드 방식이 가장 깔끔한 방식으로, 합당한 예외라고 볼 수 있습니다.</strong></p>\n<blockquote>\n<p>primitive 배열은 기본적으로 각 원소를 모두 복사해주는 <code class=\"language-text\">clone()</code>이 정의되어 있습니다. 이를 잘 활용하면 깔끔하게 깊은 복사를 진행할 수 있습니다.</p>\n</blockquote>","frontmatter":{"title":"[item13] clone 재정의는 주의해서 진행하라","summary":"`Java`에서는 `Cloneable`이라는 인터페이스를 제공합니다. 열어보면 아무 메서드도 제공하지 않는 이 인터페이스는 `Object`객체의 `clone()`을 활성화해주는 역할을 합니다.","date":"2022.07.07.","categories":["effective_java"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAABYlAAAWJQFJUiTwAAACEUlEQVQ4y52S30/aUBSA+St998FnH3zxxZj45Bv/wpaYbW4mxmwwoTADTkdrS1UmY9PoNu2lLSKgtCj98S0tMHVD9+MmJ+c2+e537+k5idROj6XMEa+KFpLusq60Scttsjsd3mp9cvoV0u4NyxsGz/KnZMrXZNWIuSSjtEirN0i6Q27XJa15JHJ6j0JZZU05QVY+U/xQ5UX+lCerZZY3zyk2TQonNxTkA9bkMkVNIG8rrG7aLL3WeZr+Rl5c8N5sklZ9Euvla7Z2bCTNJqtfsFXpslq64uVmk4x2iXTQRdpzKOxdUdjvktO7bFc6rGsOz4tNUnIb6aMTR/zC4r7DhbrN4XGeyvdP1I0GZt3ENm3qwkKcWQjDxBAWhmEhhMmZYVEXQ6ZuY4o6R1/PSUVC+dBn3ArDgCAIoh1hGMb5dv/76rghb9Q+CfmLF4NBOIAjPAjGH7q9LGJHecC2nZ9C/w50C1SrVRRFodVqIYSg1+vRaDSwbXss/6BwUCaUSiXm5+eZmZlhenqaZDLJ4uIiExMTsZi4kuDPwtFaWVlhYWGBqakpZmdnmZycZG5uLhamUqmY8X3/74RRrtVqGIYRf7uuG5fe6XQGDRjmR0sO7v3o+w34tSF3GxOMhN2hUHlkbKKIx2X0kjvj8+DYbNU8fD+kPwzvH6PvDS6z2sFAmNb65Pc9Nioe7/4zorPZXY/I9QPmkQcBe3w4NQAAAABJRU5ErkJggg=="},"images":{"fallback":{"src":"/static/327c2a185475980ae96309d9334c4ac8/3e909/effective_java_thumb.png","srcSet":"/static/327c2a185475980ae96309d9334c4ac8/7f2ad/effective_java_thumb.png 204w,\n/static/327c2a185475980ae96309d9334c4ac8/db3cb/effective_java_thumb.png 408w,\n/static/327c2a185475980ae96309d9334c4ac8/3e909/effective_java_thumb.png 815w","sizes":"(min-width: 815px) 815px, 100vw"},"sources":[{"srcSet":"/static/327c2a185475980ae96309d9334c4ac8/2ff66/effective_java_thumb.webp 204w,\n/static/327c2a185475980ae96309d9334c4ac8/1f8c8/effective_java_thumb.webp 408w,\n/static/327c2a185475980ae96309d9334c4ac8/9fe5f/effective_java_thumb.webp 815w","type":"image/webp","sizes":"(min-width: 815px) 815px, 100vw"}]},"width":815,"height":559}},"publicURL":"/static/327c2a185475980ae96309d9334c4ac8/effective_java_thumb.png"}}}}]}},"pageContext":{"slug":"/effective_java/2022-07-07-[item13]-clone 재정의는 주의해서 진행하라/"}},"staticQueryHashes":[]}