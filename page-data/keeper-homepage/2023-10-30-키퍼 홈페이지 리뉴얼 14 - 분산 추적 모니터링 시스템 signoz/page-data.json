{"componentChunkName":"component---src-templates-post-template-tsx","path":"/keeper-homepage/2023-10-30-키퍼 홈페이지 리뉴얼 14 - 분산 추적 모니터링 시스템 signoz/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<blockquote>\n<p>분산 추적 모니터링 시스템으로서 signoz를 한 번 상세하게 알아보겠습니다.</p>\n</blockquote>\n<p><a href=\"https://gusah009.github.io/keeper-homepage/2023-10-22-%ED%82%A4%ED%8D%BC%20%ED%99%88%ED%8E%98%EC%9D%B4%EC%A7%80%20%EB%A6%AC%EB%89%B4%EC%96%BC%2013%20-%20%EB%A1%9C%EA%B9%85%20%EC%8B%9C%EC%8A%A4%ED%85%9C%20%EA%B5%AC%EC%B6%95/\" target=\"_blank\" rel=\"nofollow\">이전 포스팅</a>에서 <code class=\"language-text\">signoz</code>에 대해 간단하게 알아봤는데요, 이번 포스팅에선 <strong>분산 추적 모니터링</strong>이라는 키워드에 초점을 맞춰서 <code class=\"language-text\">signoz</code>를 알아보겠습니다.</p>\n<h2>앱 여러개 띄워보기</h2>\n<p>이전 포스팅의 코드에서 간단하게 다른 포트의 앱에게 HTTP 요청을 보낼 수 있는 API를 하나만 더 추가해 보겠습니다.</p>\n<pre class=\"grvsc-container default-dark\" data-language=\"java\" data-index=\"0\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">private</span><span class=\"mtk1\"> </span><span class=\"mtk4\">final</span><span class=\"mtk1\"> </span><span class=\"mtk10\">RestTemplate</span><span class=\"mtk1\"> </span><span class=\"mtk12\">restTemplate</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">@</span><span class=\"mtk10\">GetMapping</span><span class=\"mtk1\">(</span><span class=\"mtk8\">&quot;/call&quot;</span><span class=\"mtk1\">)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">public</span><span class=\"mtk1\"> </span><span class=\"mtk10\">String</span><span class=\"mtk1\"> </span><span class=\"mtk11\">call</span><span class=\"mtk1\">(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        @</span><span class=\"mtk10\">RequestParam</span><span class=\"mtk1\"> </span><span class=\"mtk10\">int</span><span class=\"mtk1\"> port,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        @</span><span class=\"mtk10\">RequestParam</span><span class=\"mtk1\">(defaultValue = </span><span class=\"mtk8\">&quot;test&quot;</span><span class=\"mtk1\">) </span><span class=\"mtk10\">String</span><span class=\"mtk1\"> username) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">log</span><span class=\"mtk1\">.</span><span class=\"mtk11\">info</span><span class=\"mtk1\">(</span><span class=\"mtk8\">&quot;call localhost:{}...&quot;</span><span class=\"mtk1\">, port);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk10\">String</span><span class=\"mtk1\"> </span><span class=\"mtk12\">url</span><span class=\"mtk1\"> = </span><span class=\"mtk8\">&quot;http://localhost:&quot;</span><span class=\"mtk1\"> + port + </span><span class=\"mtk8\">&quot;/test?username=&quot;</span><span class=\"mtk1\"> + username;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk12\">restTemplate</span><span class=\"mtk1\">.</span><span class=\"mtk11\">getForEntity</span><span class=\"mtk1\">(url, </span><span class=\"mtk12\">String</span><span class=\"mtk1\">.</span><span class=\"mtk12\">class</span><span class=\"mtk1\">)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">            .</span><span class=\"mtk11\">getBody</span><span class=\"mtk1\">();</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<p>위와 같은 API를 추가한 앱을 여러개 띄워 보겠습니다. (각각 8081~8084 포트를 가집니다.)</p>\n<img width=\"1312\" alt=\"스크린샷 2023-10-30 22 42 34\" src=\"https://user-images.githubusercontent.com/26597702/279577975-93472d82-0be7-4b2a-99e9-627305d85736.png\">\n<p>그럼 아래와 같이 service에 앱들이 열린 것을 확인할 수 있습니다.</p>\n<img width=\"1310\" alt=\"스크린샷 2023-11-01 13 57 02\" src=\"https://user-images.githubusercontent.com/26597702/279579858-0037c6ea-b453-4c3d-ba13-b23b638790ef.png\">\n<h2>앱 끼리 통신해보기</h2>\n<p>위에서 만들었던 <code class=\"language-text\">call</code> API를 통해 앱끼리 통신을 해보겠습니다.</p>\n<ul>\n<li>8081 -> 8082</li>\n<li>8082 -> 8083</li>\n<li>8082 -> 8084</li>\n<li>8083 -> 8084</li>\n</ul>\n<img width=\"1068\" alt=\"image\" src=\"https://user-images.githubusercontent.com/26597702/279589418-b160735a-0f71-4d57-abda-c10f38fed7c1.png\">\n<p>위와 같이 통신을 하고 나면 <code class=\"language-text\">Service Map</code> 메뉴를 통해 각 앱이 어디로 트래픽을 보내고 있는지 알 수 있습니다.</p>\n<img width=\"1310\" alt=\"스크린샷 2023-11-01 15 04 59\" src=\"https://user-images.githubusercontent.com/26597702/279589744-2beb67f3-349f-476c-ac22-f952a13c45f0.png\">\n<p>한 번 8082 -> 8083 API 통신에서 Error를 일으켜 보겠습니다.</p>\n<img width=\"1162\" alt=\"image\" src=\"https://user-images.githubusercontent.com/26597702/279591605-f2e047e6-ab00-4735-a9d0-f054be3eca77.png\">\n<p>Error를 발생시키고 나면 8083 앱에 문제가 생긴것으로 인식하고 이렇게 앱이 빨간색으로 바뀌게 됩니다.</p>\n<p>추가로 8082 - 8083 사이의 선에 마우스를 올려보면 Error Rate가 50% 인 것을 확인할 수 있습니다.</p>\n<img width=\"496\" alt=\"image\" src=\"https://user-images.githubusercontent.com/26597702/279591936-17907098-b4d5-4d5f-ad34-acee162e99df.png\">\n<h2>여러 앱 사이의 exception 추적</h2>\n<p>지금처럼 8082 - 8083 사이의 통신에서 exception이 발생했을 때 보통은 양쪽 애플리케이션 로그를 모두 확인해야 합니다.</p>\n<p>하지만 signoz는 분산 추적 모니터링을 지원하기 때문에 <code class=\"language-text\">traceId</code>를 이용해 여러 앱 사이의 추적 로그를 확인할 수 있습니다.</p>\n<img width=\"1312\" alt=\"스크린샷 2023-11-01 15 23 13\" src=\"https://user-images.githubusercontent.com/26597702/279592918-3441ff07-4a88-4973-9aa0-b9b69c4583d9.png\">\n<p>위와 같이 excepton이 뜨면, 둘 중 하나를 눌러 <code class=\"language-text\">see the error in trace graph</code>를 눌러봅니다.</p>\n<img width=\"1312\" alt=\"스크린샷 2023-11-01 15 28 03\" src=\"https://user-images.githubusercontent.com/26597702/279593772-3188d91c-41e4-4e13-8919-8545bce68761.png\">\n<p>그럼 아래에서 보듯이 8082 - 8083 사이의 모든 stack trace를 보여줍니다. 물론 양쪽 애플리케이션의 로그도 모두 함께 볼 수 있구요.</p>\n<p>이런 signoz의 모니터링 능력은 MSA를 사용하거나 해서 애플리케이션간 연결 depth가 깊어지면 깊어질수록 진가를 발휘합니다.</p>\n<h2>어떻게 여러 앱들 사이에서 종합적인 모니터링이 가능할까?</h2>\n<h3>trace와 span</h3>\n<p><img src=\"https://user-images.githubusercontent.com/26597702/280001620-08eb17a6-b9db-49ca-ad84-23381c8484ec.png\" alt=\"image\"></p>\n<p>분산 추적에서 추적에 해당하는 <code class=\"language-text\">trace</code>는 사용자 요청의 시작과 끝을 의미합니다. 그리고 여러개의 <code class=\"language-text\">span</code>으로 구성되는데, <code class=\"language-text\">span</code>은 사용자 요청에서 작업을 완료하는 논리적 단위입니다.</p>\n<p><code class=\"language-text\">span</code>에 대해서 알아야 할 몇 가지만 적어보자면,</p>\n<ul>\n<li>\n<p>Root Span: <code class=\"language-text\">trace</code>의 첫 번째 <code class=\"language-text\">span</code>을 나타내는 상위 스팬입니다.</p>\n</li>\n<li>\n<p>Child Span: <code class=\"language-text\">Child Span</code>(자식 스팬)은 부모 스팬에 의해 트리거되며 함수 호출, DB 호출, 다른 서비스에 대한 호출 등이 될 수 있습니다.</p>\n</li>\n<li>\n<p>Duration or Latency: 각 스팬이 프로세스를 완료하는 데 걸리는 시간입니다. 애플리케이션 성능을 분석하는 데 사용되는 주요 데이터 포인트입니다.</p>\n</li>\n<li>\n<p>Causal relationship(인과 관계): 추적은 요청에 관련된 모든 스팬을 순차적 관계로 연관시킵니다.</p>\n</li>\n</ul>\n<p>우리가 <code class=\"language-text\">Traces</code> 섹션에서 봤던 각각의 bar가 하나의 span이고, 이를 통해 어디서 시간이 오래 걸렸는지 확인할 수 있습니다.</p>\n<h3>그럼 traceId는 어디서 만들어질까?</h3>\n<p>그럼 모든 애플리케이션을 지나가는 이 traceId는 어디서 만들어지고, 어떻게 전달될 수 있을까요?</p>\n<p>서비스간의 통신에서 상대방이 받은 메시지중에 어떤 메시지가 내가 N번째로 보낸 메시지인지 어떻게 알 수 있을까요?</p>\n<p>이는 아주 간단한데, 메시지를 보내는 쪽에서 <code class=\"language-text\">traceId</code>에 해당하는 태그를 같이 보내주는 것입니다. (이를 위해 javaagent가 필요했습니다.)</p>\n<blockquote>\n<p>TCP나 운영체제의 수준에서 메시지를 추적하려는 시도가 있었지만 프로토콜마다 별도로 구현해야 해 복잡도가 높고 성능이 좋지 않았다. 또한 메시지를 정확하게 추적하기 어려웠다.</p>\n<p>출처: <a href=\"https://d2.naver.com/helloworld/1194202\" target=\"_blank\" rel=\"nofollow\">대규모 분산 시스템 추적 플랫폼, Pinpoint</a></p>\n</blockquote>\n<h3>traceId의 특징</h3>\n<p>수많은 endpoint에서 요청이 들어올 것이고, 마찬가지로 <code class=\"language-text\">traceId</code>도 무수히 많이 생길 수 밖에 없습니다.</p>\n<p>이를 위해 <code class=\"language-text\">w3c</code>에선 분산 추적 표준을 지정해놨는데요, 그 중 <code class=\"language-text\">traceId</code> 필드 생성에 대한 고려 사항을 함께 살펴보겠습니다. (이는 권장사항으로 표준은 아닙니다.)</p>\n<ol>\n<li>uniqueness</li>\n<li>randomness</li>\n<li>traceId가 더 짧더라도 호환성을 유지해야함.</li>\n</ol>\n<p>중복값이 최대한 적어야하고, 정보 보안을 위해 최대한 랜덤해야 한다고 되어 있습니다.</p>\n<p>출처: <a href=\"https://www.w3.org/TR/trace-context/#considerations-for-trace-id-field-generation\" target=\"_blank\" rel=\"nofollow\">https://www.w3.org/TR/trace-context/#considerations-for-trace-id-field-generation</a></p>\n<h2>마치며</h2>\n<p>여기까지 signoz에 대해서 알아봤는데요, 마냥 좋기만 할 줄 알았던 <code class=\"language-text\">signoz</code>에도 큰 단점이 있었습니다.</p>\n<p>바로 <strong>높은 카디널리티의 식별자에 대한 로그</strong>였는데요, 저희 팀은 사용자 문의가 들어오면 특정 요청에 대한 로그를 볼 일이 많은데, 그런 특정 요청에 대해서는 <code class=\"language-text\">elasticSearch</code>보다 한참 느린 모습을 보여줬습니다.</p>\n<img width=\"742\" alt=\"image\" src=\"https://user-images.githubusercontent.com/26597702/280000798-59211800-0d7e-491e-89ca-3d5fcf1f8f9d.png\">\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 128px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/3d8179acc52d510f5445234b54b68a6f/82763/image.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 100%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAABYlAAAWJQFJUiTwAAABhUlEQVQ4y62Ua0/CMBSGh+4+NhhzMBhMbkOYkatk4aJ4i1HjVxD//w95TRshQwbbiB+arkv79Dk97WFWX99gUjwUNQdJySZqopzZ9qKk0W/mGHCzIGq8C1yt/xl4wHAzWZA0cLwCXlT3oKHAZYhhEJbRC3A7fZiFCgRJ3QMlCpkAve4YlWoL130fWtbcLowdcjAklpfh1Npw2z00rrrUcAeS9AyL5TqcehvTxRta3gC204Ss5k4LmUwqX7qoNjyM/Ae4nQG1lUPOOtJQEFV6fiSzLCejO5xCN4o4ZyW6mPz/m+2DhgRETHKmvV3UG81+s6xBTuuw7BrtYxmS3fu3c9wMJjhjRTomQCNfBpPi6DnOHt6haEY8ILFQMxcYT5/Q8obQ9DwFFko1WHYd/vwFJadJ50WGvNmRWGUNCyN/gfnjB+6fP2k/uXulhpyQ3ktgwHAdeg+JAWmm5dCXYjsuncMHYLGzHMwgseXFNLUKu9SJi8OxCpT4LR8CnFxgT6rYywjDpMAfM2DlJ+xXMyoAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <picture>\n          <source srcset=\"/static/3d8179acc52d510f5445234b54b68a6f/ea180/image.webp 128w\" sizes=\"(max-width: 128px) 100vw, 128px\" type=\"image/webp\">\n          <source srcset=\"/static/3d8179acc52d510f5445234b54b68a6f/82763/image.png 128w\" sizes=\"(max-width: 128px) 100vw, 128px\" type=\"image/png\">\n          <img class=\"gatsby-resp-image-image\" src=\"/static/3d8179acc52d510f5445234b54b68a6f/82763/image.png\" alt=\"image\" title=\"image\" loading=\"lazy\" decoding=\"async\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\">\n        </picture>\n  </a>\n    </span>\n<p>집계 쿼리에 대해선 월등히 빠른 모습을 보여주고 있어서, 팀별로 정말 signoz가 필요한지 다시 한 번 확인하고 사용하는게 좋아보입니다.</p>\n<style class=\"grvsc-styles\">\n  .grvsc-container {\n    overflow: auto;\n    position: relative;\n    -webkit-overflow-scrolling: touch;\n    padding-top: 1rem;\n    padding-top: var(--grvsc-padding-top, var(--grvsc-padding-v, 1rem));\n    padding-bottom: 1rem;\n    padding-bottom: var(--grvsc-padding-bottom, var(--grvsc-padding-v, 1rem));\n    border-radius: 8px;\n    border-radius: var(--grvsc-border-radius, 8px);\n    font-feature-settings: normal;\n    line-height: 1.4;\n  }\n  \n  .grvsc-code {\n    display: table;\n  }\n  \n  .grvsc-line {\n    display: table-row;\n    box-sizing: border-box;\n    width: 100%;\n    position: relative;\n  }\n  \n  .grvsc-line > * {\n    position: relative;\n  }\n  \n  .grvsc-gutter-pad {\n    display: table-cell;\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  .grvsc-gutter {\n    display: table-cell;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter::before {\n    content: attr(data-content);\n  }\n  \n  .grvsc-source {\n    display: table-cell;\n    padding-left: 1.5rem;\n    padding-left: var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem));\n    padding-right: 1.5rem;\n    padding-right: var(--grvsc-padding-right, var(--grvsc-padding-h, 1.5rem));\n  }\n  \n  .grvsc-source:empty::after {\n    content: ' ';\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter + .grvsc-source {\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  /* Line transformer styles */\n  \n  .grvsc-has-line-highlighting > .grvsc-code > .grvsc-line::before {\n    content: ' ';\n    position: absolute;\n    width: 100%;\n  }\n  \n  .grvsc-line-diff-add::before {\n    background-color: var(--grvsc-line-diff-add-background-color, rgba(0, 255, 60, 0.2));\n  }\n  \n  .grvsc-line-diff-del::before {\n    background-color: var(--grvsc-line-diff-del-background-color, rgba(255, 0, 20, 0.2));\n  }\n  \n  .grvsc-line-number {\n    padding: 0 2px;\n    text-align: right;\n    opacity: 0.7;\n  }\n  \n  .default-dark {\n    background-color: #1E1E1E;\n    color: #D4D4D4;\n  }\n  .default-dark .mtk4 { color: #569CD6; }\n  .default-dark .mtk1 { color: #D4D4D4; }\n  .default-dark .mtk10 { color: #4EC9B0; }\n  .default-dark .mtk12 { color: #9CDCFE; }\n  .default-dark .mtk8 { color: #CE9178; }\n  .default-dark .mtk11 { color: #DCDCAA; }\n  .default-dark .mtk15 { color: #C586C0; }\n  .default-dark .grvsc-line-highlighted::before {\n    background-color: var(--grvsc-line-highlighted-background-color, rgba(255, 255, 255, 0.1));\n    box-shadow: inset var(--grvsc-line-highlighted-border-width, 4px) 0 0 0 var(--grvsc-line-highlighted-border-color, rgba(255, 255, 255, 0.5));\n  }\n</style>","frontmatter":{"title":"키퍼 홈페이지 리뉴얼 14 - 분산 추적 모니터링 시스템 signoz","summary":"분산 추적 모니터링 시스템으로서 signoz를 한 번 상세하게 알아보겠습니다.","date":"2023.10.30.","categories":["keeper_homepage"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/webp;base64,UklGRjIBAABXRUJQVlA4WAoAAAAQAAAAEwAACQAAQUxQSC0AAAABR6CgbRuGP+L+jUZExCfJToChtlEu54BgCBOEN2KQvh8CIvo/ARm4FtYX03gAVlA4IN4AAACwAgCdASoUAAoAAAAAJZwCdDKgOldBrwdKF7pGdCAA/v//nIPy78T/zRf8Gcn+PJY+6bgAAz1MS8uxGEpQPj7v/V1n/5v734d+/9/ins5Uf1P/Knle75nH513gNqYv7J/kKwFWkuB+pT34t4Ou/CmEzI/eKxonL7DHj2hSg4cfgTwxfQfcAf/ZyZxW3bHjQaZ/xXVizPm/3ofp9XZbWx9y/+0/2Pe4/+JI2S71DHOyMsVp+0HJXUZGcA05gvwmj4ofwwB7nBL6h+0Hjw5xOL5q6rT6/gBvfs2wtbCAAAA="},"images":{"fallback":{"src":"/static/1e9b6b767c48250a98abf4ecfb165fc1/36677/signoz.webp","srcSet":"/static/1e9b6b767c48250a98abf4ecfb165fc1/f9871/signoz.webp 483w,\n/static/1e9b6b767c48250a98abf4ecfb165fc1/9d54a/signoz.webp 966w,\n/static/1e9b6b767c48250a98abf4ecfb165fc1/36677/signoz.webp 1932w","sizes":"(min-width: 1932px) 1932px, 100vw"},"sources":[]},"width":1932,"height":1009}},"publicURL":"/static/1e9b6b767c48250a98abf4ecfb165fc1/signoz.webp"}}}}]}},"pageContext":{"slug":"/keeper-homepage/2023-10-30-키퍼 홈페이지 리뉴얼 14 - 분산 추적 모니터링 시스템 signoz/"}},"staticQueryHashes":["2518467932","429584967"]}