{"componentChunkName":"component---src-templates-post-template-tsx","path":"/etc/2024-07-28-CRDT 심화/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<h2>conflict-free 하다는게 어떤걸까?</h2>\n<p>모호한 표현이지만, 간단하게 설명하면 “독점 쓰기”가 필요하지 않고 “결정론적인 자동 충돌 해결”을 수행할 수 있는 데이터 구조에서 동작한다고 할 수 있습니다.</p>\n<p>충돌이 전혀 발생하지 않는다는 것은 아닙니다. 충돌이 발생해도 <strong>구조 자체에 포함된 메타데이터</strong>를 이용해 <strong>충돌을 해결</strong>하고 출력을 결정할 수 있다는 뜻입니다.</p>\n<p>CRDT는 크게 state-based 와 op-based (operation) 방식으로 나뉘어지는데요,</p>\n<ul>\n<li>상태기반 CRDT는 데이터 구조의 일부로 메타데이터를 넣는 경향이 있고,</li>\n<li>명령기반 CRDT는 복제 프로토콜 자체에 메타데이터를 더 많이 넣는 경향이 있습니다.</li>\n</ul>\n<h2>CRDT의 가장 중요한 “병합” 메서드</h2>\n<p>CRDT는 앞서 말했듯이 데이터의 일관성을 “독점 쓰기”가 아니라 <strong>“결정론적인 자동 충돌 해결”</strong> 을 통해 수행한다고 설명했습니다.</p>\n<p>이 때 충돌이 발생하면 해결하는 과정을 병합이라고 부릅니다.</p>\n<p>이 때 <strong>병합 연산은 3가지 특성을 만족</strong>해야 합니다.</p>\n<ol>\n<li>교환 법칙: A • B = B • A</li>\n<li>결합 법칙: (A • B) • C = A • (B • C)</li>\n<li>멱등성: A • A = A</li>\n</ol>\n<blockquote>\n<p><em>여기서 • 연산은 미지의 병합 연산이라고 생각해주면 됩니다.</em></p>\n</blockquote>\n<p>이 속성들을 모두 만족 시키기는 쉽지 않지만, <strong>이 조건들을 만족 시키는 순간 얼마나 큰 효과를 얻을 수 있는지 지금 부터 알아보겠습니다.</strong></p>\n<p>아래 두 가지는 위 조건을 만족하는 아래에서 사용할 예시입니다.</p>\n<ol>\n<li>두 집합의 합집합</li>\n<li>두 값의 max</li>\n</ol>\n<h2>state-based</h2>\n<p>만약 상태를 기반으로 복제본을 맞춘다면, 연산을 끝낸 후 나의 데이터를 상대에게 보내면 됩니다.</p>\n<p>2번 예시를 가져와 보면, A가 연산을 마쳤을 때 max 값이 5라면 본인의 값인 5를 다른 노드들에게 전달해주면 됩니다.</p>\n<p>그럼 다른 노드들이 받은 데이터와 본인의 데이터를 max 연산하여 데이터 정합성을 맞출 수 있게 됩니다.</p>\n<p>상태 기반 CRDT는 단순하지만 엔지니어링적으로 살펴보면 문제를 발견할 수 있는데요,</p>\n<p>이번엔 1번 예시를 가져와서 A가 1000개의 요소가 있는 집합에 1개의 원소만 추가한다고 해보겠습니다.</p>\n<p>그럼 A는 1001개의 모든 데이터를 다른 노드들에게 전달해줘야 해 매우 비효율적으로 동작하기 시작합니다.</p>\n<p>이 문제를 해결하기 위해 나온 것이 delta-state-based 방식입니다.</p>\n<p>delta-state-based 방식은 이후에 보도록 하고, 또 다른 예시로 Counter를 살펴보겠습니다.</p>\n<h3>G-Counter (Growing-only Counter)</h3>\n<p>G-Counter는 증가연산만 있는 CRDT입니다.</p>\n<p>카운터는 증가만 가능하기 때문에 “병합”과정에서 다른 노드와의 값 중에 큰 값을 취하는 식(max연산)으로 전략을 가져갈 수 있습니다.</p>\n<ol>\n<li><code class=\"language-text\">A: 4   B: 4</code> (동기화 상태)</li>\n<li><code class=\"language-text\">A: 6   B: 5</code> (동시에 A가 2 / B가 1 증가함)</li>\n<li><code class=\"language-text\">A: 6 ↔ B: 5</code> (동기화 시작)</li>\n<li><code class=\"language-text\">A: 6   B: 6</code> (더 큰 값인 6으로 동기화)</li>\n</ol>\n<p>max 연산은 3가지 법칙(교환, 결합, 멱등성)을 만족하기 때문에 G-Counter는 CRDT로 충분히 자격이 있습니다.</p>\n<h3>Increment/decrement Counter</h3>\n<p>이번엔 증가뿐만 아니라 감소도 있는 카운터의 예시를 보겠습니다. (이를 <strong>PNCounter</strong> 라고 부르겠습니다.)</p>\n<p>혹시 위의 G-Counter에 감소 연산만 넣으면 된다고 생각했다면 다시 생각해봐야 합니다.</p>\n<p>감소를 할 수 있다는 전제가 들어가는 순간 병합 과정에서 최대값을 취하는 전략은 더 이상 옳지 않게 됩니다.</p>\n<p>반례를 하나 들어보겠습니다.</p>\n<ol>\n<li><code class=\"language-text\">A: 5   B: 5</code> (동기화 상태)</li>\n<li><code class=\"language-text\">A: 4   B: 5</code> (A 감소)</li>\n<li><code class=\"language-text\">A: 4 → B: 5</code> (동기화 시도. 하지만 B 값이 더 커서 무시)</li>\n<li><code class=\"language-text\">A: 4   B: 5</code> (정합성 깨짐)</li>\n</ol>\n<p>그럼 어떻게 state-based CRDT에서 증감 카운터를 만들 수 있을까요?</p>\n<p>바로 G-Counter를 두 개 사용하는 전략입니다.</p>\n<p>G-Counter는 위 3가지 법칙(교환, 결합, 멱등성)을 만족하는 것을 확인했으므로 증감 카운터를 만드는데 문제가 없습니다.</p>\n<p>사용자에게 보여줄 최종 value는 그저 G-Counter 두 개의 합을 보여주면 됩니다.</p>\n<h2>Register</h2>\n<p>간단하게 값을 저장하는 register를 CRDT로 만들어보겠습니다.</p>\n<p>그런데 변경에 대한 순서를 알 수 없다는 문제가 있는데요, 아래는 간단한 예시입니다.</p>\n<ol>\n<li><code class=\"language-text\">A: 5   B: 3</code> (A는 값을 5로, B는 값을 3으로 바꿨다)</li>\n<li><code class=\"language-text\">A → C, B → D</code> (A는 변경된 값을 C에게 먼저, B는 값을 D에게 먼저 보냈다)</li>\n<li><code class=\"language-text\">C: 5  D: 3</code> (C는 5, D는 3의 값을 가지게 됐다)</li>\n<li><code class=\"language-text\">A → D, B → C</code> (이제 A와 B가 나머지 노드에게 변경사항을 전달한다)</li>\n<li><code class=\"language-text\">C: 3   D: 5</code> (C는 3 D는 5를 가진채로 동기화가 끝났다)</li>\n</ol>\n<h3>Logical Clock</h3>\n<p>우리는 앞서 계속 얘기할 때 이벤트가 일어난 순서, 즉 인과관계를 무시하고 있었습니다.</p>\n<p>이제 여기에 이벤트의 인과관계라는 개념을 더할건데, 엔지니어링적으로 local의 timestamp를 사용할 순 없습니다.</p>\n<p>이를 위해 우리는 분산 시스템에 대해 알아야 하는데 여기서 논할 주제는 아니므로 넘어가겠습니다. (간단하게 <strong>여러 컴퓨터가 있는 현실세계</strong>라고 생각하시면 됩니다.)</p>\n<p>여러 컴퓨터가 있는 현실세계에서 timestamp를 왜 사용할 수 없을까요?</p>\n<p>사실 컴퓨터의 시간은 절대적이지 않습니다. NTP라는 프로토콜을 통해 계속 오차를 맞춰나가는데 아쉽게도 완벽하게 정확한 시계는 없습니다.</p>\n<p>그래서 실제로는 A 컴퓨터에서 먼저 발생한 이벤트가 B 컴퓨터에 도착했을 땐 나중에 발생한 이벤트처럼 보일 수 있습니다. (A 컴퓨터 시계가 B 컴퓨터 시계보다 빠를 때)</p>\n<p>이를 해결하기 위해 나온 것이 Logical Clock입니다.</p>\n<p>논리 시계는 인과관계를 표현하기 위한 시계로, 이벤트가 발생할 때 마다 단조증가 하는 시계입니다.</p>\n<p>그 중 우리는 Vector Clock에 대해 알아보겠습니다.</p>\n<h3>Vector Clock</h3>\n<p>Vector Clock은 Logical Clock의 종류 중 하나로, 각각의 노드가 본인만의 G-Counter를 가지고 있는 형태라고 보면 됩니다.</p>\n<p>먼저 나의 노드에서 이벤트가 발생하면 나의 G-Counter 값을 올립니다.</p>\n<p>Vector Clock은 아래와 같은 형상입니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 600px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/608dee0356166135a245b5efe3834bc7/dface/Untitled.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 38.020833333333336%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAACNklEQVQozzVRW1NSURhd+1w4AnLUMEGO5wARSsUpFA9exm464uDkNW0SDfCCUemMYiro1PjgMKMPNlNxCQxLx7GZeuy5v0azUdfDt7+Zvb5vrb02MuUTwdHbKwBgFo5/yAuFknOpfOaI5vLKXDYvRQvHUvTwQB/5VnbHPh01RIvfbdF8yRMrlW9NpLaMsXzRHMmVXB2DAzzdgY8Xv6TW/gEJgN41PNWhBMdlV3CsI7Sy0/Yotuqzh6ZaAdRqi+vBZpNB9M/EtQfh5e6e+EYvAJ63tCh3X731ATAQjjfhXzhsVJ+NGAAQr1/Vx79+sQaT202pg1Pn+v6xMrmfkWYyGVvPjSZd6vCnLbG6Z65UKgg7Nd1q9sI18WGv7fnrSHVebDQz+LO2ZnGNjN6kDiXVV+fR2i33JucCnuEXVvfQpCeQ2Ljv7VTrARiXNw/Uh/0jjZQLoMY7Pa/1rWy6JaciAhAJw5hwvrtrmBZFqoCX2++FSLbY2pdYafhbqaCqCpD5QlGOfz7xLY4t8O+Ozm3ho5x1KZttkZr0ut+XPIbjeaaa4fnObvOg3W6lOdEcHE9DvjuzCTd1INSbRUHgTTZ/t+JdXFcBsMrjUKBtfNZdAxhNVpvICoKJEEJn66hLnKXSGHc6qQp01QqWFoNF4pjLnpUFVvfGK+lk1c9f31+dLCGEA8DhGqfpNEavFlLYnwyRRrWT2idSi8zQD1hLJmu3UunbfV0aCy1I5PYuhgEIw3GE8qpPvcJ/q85/E+PAx2YAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n          <source\n              srcset=\"/static/608dee0356166135a245b5efe3834bc7/a59e9/Untitled.webp 192w,\n/static/608dee0356166135a245b5efe3834bc7/0ca9f/Untitled.webp 384w,\n/static/608dee0356166135a245b5efe3834bc7/411c4/Untitled.webp 600w\"\n              sizes=\"(max-width: 600px) 100vw, 600px\"\n              type=\"image/webp\"\n            />\n          <source\n            srcset=\"/static/608dee0356166135a245b5efe3834bc7/3b721/Untitled.png 192w,\n/static/608dee0356166135a245b5efe3834bc7/66595/Untitled.png 384w,\n/static/608dee0356166135a245b5efe3834bc7/dface/Untitled.png 600w\"\n            sizes=\"(max-width: 600px) 100vw, 600px\"\n            type=\"image/png\"\n          />\n          <img\n            class=\"gatsby-resp-image-image\"\n            src=\"/static/608dee0356166135a245b5efe3834bc7/dface/Untitled.png\"\n            alt=\"Untitled\"\n            title=\"Untitled\"\n            loading=\"lazy\"\n            decoding=\"async\"\n            style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n          />\n        </picture>\n  </a>\n    </span></p>\n<p>Vector Clock에서 인과관계를 확인하는 법은 ‘모든 Vector 값이 더 크거나 같냐?’ 입니다.</p>\n<p><code class=\"language-text\">b</code>와 <code class=\"language-text\">i</code>를 보겠습니다.</p>\n<p><code class=\"language-text\">b</code>와 <code class=\"language-text\">i</code>를 비교해보면 <code class=\"language-text\">i</code>가 모든 값에 대해 <code class=\"language-text\">b</code>보다 크거나 같기 때문에 명확히 <code class=\"language-text\">b</code> 다음에 <code class=\"language-text\">i</code>가 일어난 것을 알 수 있습니다.</p>\n<p>그럼 <code class=\"language-text\">b</code>와 <code class=\"language-text\">h</code>는 어떨까요?</p>\n<p>둘은 비교할 수가 없는데요, P0값은 <code class=\"language-text\">b</code>가 더 큰데 P1 값은 <code class=\"language-text\">h</code>가 더 크기 때문에 누가 먼저 발생한건지 인과관계를 따질 수 없습니다.</p>\n<p>이 상황에서 <code class=\"language-text\">i</code>로 합쳐지게 되면 CRDT 입장에선 이를 <strong>“충돌”(중요)</strong> 로 여깁니다.</p>\n<p><strong>그럼 “병합” 과정이 일어나는 것입니다.</strong></p>\n<h3>다시 register로 돌아와서</h3>\n<p>아까 문제가 됐던 요청이 왔을 때 어떤 값을 선택할 것이냐?는 이제 vector clock으로 해결이 됩니다.</p>\n<p>들어온 이벤트 중 vector clock이 높은 걸 기준으로 값을 가져가면 됩니다.</p>\n<h2>참고</h2>\n<p><a href=\"https://interjectedfuture.com/trade-offs-between-different-crdts/\" target=\"_blank\" rel=\"nofollow\">https://interjectedfuture.com/trade-offs-between-different-crdts/</a></p>\n<p><a href=\"https://www.sciencedirect.com/science/article/abs/pii/S0743731517302332\" target=\"_blank\" rel=\"nofollow\">https://www.sciencedirect.com/science/article/abs/pii/S0743731517302332</a></p>\n<p><a href=\"https://people.cs.rutgers.edu/~pxk/417/notes/clocks/index.html\" target=\"_blank\" rel=\"nofollow\">https://people.cs.rutgers.edu/~pxk/417/notes/clocks/index.html</a></p>\n<style class=\"grvsc-styles\">\n  .grvsc-container {\n    overflow: auto;\n    position: relative;\n    -webkit-overflow-scrolling: touch;\n    padding-top: 1rem;\n    padding-top: var(--grvsc-padding-top, var(--grvsc-padding-v, 1rem));\n    padding-bottom: 1rem;\n    padding-bottom: var(--grvsc-padding-bottom, var(--grvsc-padding-v, 1rem));\n    border-radius: 8px;\n    border-radius: var(--grvsc-border-radius, 8px);\n    font-feature-settings: normal;\n    line-height: 1.4;\n  }\n  \n  .grvsc-code {\n    display: table;\n  }\n  \n  .grvsc-line {\n    display: table-row;\n    box-sizing: border-box;\n    width: 100%;\n    position: relative;\n  }\n  \n  .grvsc-line > * {\n    position: relative;\n  }\n  \n  .grvsc-gutter-pad {\n    display: table-cell;\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  .grvsc-gutter {\n    display: table-cell;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter::before {\n    content: attr(data-content);\n  }\n  \n  .grvsc-source {\n    display: table-cell;\n    padding-left: 1.5rem;\n    padding-left: var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem));\n    padding-right: 1.5rem;\n    padding-right: var(--grvsc-padding-right, var(--grvsc-padding-h, 1.5rem));\n  }\n  \n  .grvsc-source:empty::after {\n    content: ' ';\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter + .grvsc-source {\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  /* Line transformer styles */\n  \n  .grvsc-has-line-highlighting > .grvsc-code > .grvsc-line::before {\n    content: ' ';\n    position: absolute;\n    width: 100%;\n  }\n  \n  .grvsc-line-diff-add::before {\n    background-color: var(--grvsc-line-diff-add-background-color, rgba(0, 255, 60, 0.2));\n  }\n  \n  .grvsc-line-diff-del::before {\n    background-color: var(--grvsc-line-diff-del-background-color, rgba(255, 0, 20, 0.2));\n  }\n  \n  .grvsc-line-number {\n    padding: 0 2px;\n    text-align: right;\n    opacity: 0.7;\n  }\n  \n</style>","frontmatter":{"title":"CRDT 심화","summary":"Conflict Free 하다는게 어떤걸까?","date":"2024.07.28.","categories":["crdt","yorkie"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAsTAAALEwEAmpwYAAADo0lEQVQ4y32VSUhjSRjHnwlR8KKieDFRjEt7iBBB8WBcIuTixYgwguIyohiVzMGTuAyMKIiKgwOKuA4yJ22U9mArgsuACw2Sw4yKIigyDCIqYzbNe6/q33xFIrYdp6Dyqr6q+tW31RdJURTp5uYmBoAVgB1AHQAngJ8B/AbgDwCfAXwBcAHgPwAygF2Px5MPQHK5XBJjTEtjSVVVC4B/FUXB3d0dLi8v4XK5sL29jeXlZczMzGBoaAidnZ1ob29HbW0tKisr+crKCoLtF0mSIhhjEgAt/Zyvr6/DYDCo6enpjL6ZmZmy2WyWCwoKFJvNptjtdrWmpoY5nU42MDDA6YKsrCyluroaXq+XoF/cbrdZaEizhoYGVZIkPjU1xQGEOt6M8VbW2NjI09LS5N3dXbGgqmo1AdW2tjYQMDIykvf29mJnZweLi4vC3JGREZDM6XSivr4eFRUVKC0thdVq5Varlc5RV2ZnZ4npIyBraWkRQI1GIzbExMQgNTUVGRkZMJlMyM3NJYCA1dXVCXh3dzcGBwfJlzwnJ4fWGRG/ARIsMTERV1dX4Pytpe823tHRIbSl8XfAlJQUUMQZY5ibm8Po6Ch6enpwcnIiTp+dnaG8vBx5eXkYGxsTMofD8T5Qr9fD5/Ph6emJghXyEQoLC19UohSKj4/H4+OjmLe2tiII/N7k5OTkl41HR0fQarXQ6XQC2t/fL+TT09MwGo2QZVnMKajvAg0GA9xut1hcW1tDbGysiC6tUdDIvwsLC8KS5+fn8ECHwxEWuLm5KbQ7Pz+HzWYT0LKyMkxMTIgsILeEA6r/B4yIiMD19TVOT08RSiuCZWdnC1+H1bC5uZkHnc9fA7e2thAVFYWLiwsx7+vrewkS5aff7w8LvBwfH6dNLKghDwVldXVVHKYvNUql/Px8IUtKSgq9Y0obvE4bp6qqKC4uVkhDo9HIfT4f93g84uaioiI0NTXh4eFBHKZqRK+F/PheYlP/eHt7SxGVExISwhYFejl0id/vJws4+XV/f5/v7e1xs9nMX57e/f29ND8/Hw3gr8PDQzJHLikpgd1u5xaLhZtMJq7X61lcXJwaHR1NVUkJdlmj0cg6nY5k6uTkJPH8VGC1gUCAqvYHAJ6NjQ1YLBZGaVJVVSX809XVheHhYZHQS0tLoD0HBwc4Pj4WGRD0uQLgR2Ey51xAvV5vHoC/X9U9yot/SHsAfwL4BOB3AL8G/yJ+IgiAHwKBQAYV2K+VHz2VfZz9JAAAAABJRU5ErkJggg=="},"images":{"fallback":{"src":"/static/73d79c4eb6f00426e49f551564b50291/1689d/notion-icon.png","srcSet":"/static/73d79c4eb6f00426e49f551564b50291/8a20a/notion-icon.png 512w,\n/static/73d79c4eb6f00426e49f551564b50291/34104/notion-icon.png 1024w,\n/static/73d79c4eb6f00426e49f551564b50291/1689d/notion-icon.png 2048w","sizes":"(min-width: 2048px) 2048px, 100vw"},"sources":[{"srcSet":"/static/73d79c4eb6f00426e49f551564b50291/3591c/notion-icon.webp 512w,\n/static/73d79c4eb6f00426e49f551564b50291/e306d/notion-icon.webp 1024w,\n/static/73d79c4eb6f00426e49f551564b50291/035dc/notion-icon.webp 2048w","type":"image/webp","sizes":"(min-width: 2048px) 2048px, 100vw"}]},"width":2048,"height":2048}},"publicURL":"/static/73d79c4eb6f00426e49f551564b50291/notion-icon.png"}}}}]}},"pageContext":{"slug":"/etc/2024-07-28-CRDT 심화/"}},"staticQueryHashes":["2518467932","429584967"]}